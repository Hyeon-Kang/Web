문자열 비교는 논리연산자 ==이 아닌 equals("aaa")를 사용해야 함
ex) String str ="aaa";
    while(! str.equals("aaa") ){
    ......
    }

데이터 타입 분류

기본 (privitive type)
 - 정수 byte, int...
 - 실수 float, double
 - 논리 boolean


참조 (reference type)
 - array
 - enum
 - class
 - interface

 메모리 사용 영역

  - Heap : class와 array 생성, 실행중인 스레드 안의 JVM 스택에서 이곳을 참조하여
    필요한 데이터를 참조함

 new 를 사용하여 새로운 class 생성 (참조 대상이 같은지 다른지 유의!)

 다른 언어와 같이 parameter를 프로그램 혹은 함수 내부로 전달하려면 다음과 같이

 String args = {문자열0, 문자열1, 문자열2 ...};

 public static void main (String[] args) {
 ...
 }

 또는 다음과 같이 실행

 java 프로그램_이름 10 20

 근데 자바는 다른 프로그램과 달리 0, 1번 배열에 프로그램 저장 경로 등
 시스템 값이 안 들어가나?

 저장 데이터 제한하기 -> 열거형 (Enum)

 정적 초기화 블록

 ex class {
  static string a = "aa";
  static string b = "bb";
  static string c;
  static {
    c = a + "+" + b;
  }
 }


 singleton class
 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우

 이 경우 단 하나의 생성된 객체 이외의 다른 객체가 생성됨을 막기 위해
 class 외부에서 new 생성자를 호출할 수 없도록 막아야 함

 애플리케이션이 시작될 때 어떤 클래스가 최초 한번만 메모리를 할당하고(Static) 그 메모리에 인스턴스를 만들어 사용하는 디자인패턴.

생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나고 최초 생성 이후에 호출된 생성자는 최초에 생성한 객체를 반환한다.
(자바에선 생성자를 private로 선언해서 생성 불가하게 하고 getInstance()로 받아쓰기도 함)

싱글톤 패턴을 쓰는 이유

고정된 메모리 영역을 얻으면서 한번의 new로 인스턴스를 사용하기 때문에 메모리 낭비를 방지할 수 있음

또한 싱글톤으로 만들어진 클래스의 인스턴스는 전역 인스턴스이기 때문에 다른 클래스의 인스턴스들이 데이터를 공유하기 쉽다.

DBCP(DataBase Connection Pool)처럼 공통된 객체를 여러개 생성해서 사용해야하는 상황에서 많이 사용.

(쓰레드풀, 캐시, 대화상자, 사용자 설정, 레지스트리 설정, 로그 기록 객체등)

안드로이드 앱 같은 경우 각 액티비티나 클래스별로 주요 클래스들을 일일이 전달하기가 번거롭기 때문에 싱글톤 클래스를 만들어 어디서나 접근하도록 설계하는 것이 편하기 때문...




멀티쓰레드환경에서 동기화처리를 안하면 인스턴스가 두개가 생성된다든지 하는 경우가 발생할 수 있음

개발을 할때 항상 들어온 goto는 쓰면 안돼! 전역 객체는 안 좋은거야! 라는 말 처럼 꼭 필요한 경우아니면 지양해야함. // 적절히 잘 쓰면 아주 좋음, (그게 어렵지)


멀티 스레드 환경에서 싱글톤 클래스, 인스턴스 만드는 방법

출처: https://jeong-pro.tistory.com/86 [기본기를 쌓는 정아마추어 코딩블로그]



자바 클래스로더

: 자바 클래스를 JVM으로 동적 로드하는 JRE(자바 런타임 환경) 의 일부이다.

일반적으로 클래스는 요청 시 한 차례만 로드됨.

JRE는 클래스 로더 덕분에 파일과 파일 시스템에 대해 알 필요가 없다.
(하위 모듈 개념)

자바 클래스로더는 2가지 로드 방식이 있다.
1. 런타임 로딩 (요청 시 로드)
2. 로드 타임 로딩 (런타임 로딩에 의해 A클래스가 로딩될 때 내부에서 참조하는
   B, C 클래스도 같이 로딩)
   이 경우 원자적 특성으로 방해받지 않는 듯





final field & constant

final 필드는 초기값이 저장되면 해당 필드 내용 불변

C 언어의 상수와 비슷하다. (static 까지 붙이면 같아진다.)

final 필드의 초기값 부여는 두 가지 경우밖에 없다.
1. 필드 선언 시 부여 (가장 편함. 그냥 class field 생성 시 기재하면 끝!)
2. 생성자에서 부여 (final init.java 에서 예제 확인)

final field는 비워두면 당연히 컴파일 에러 발생!

static final int = C언어 constant int




package

패키지는 단순히 파일시스템의 폴더 기능만이 아닌 클래스의 일부분이다.

패키지는 클래스의 유일성을 유지시켜줌

가량 클래스 이름이 같아도 패키지가 다르면 다른 클래스로 식별

class AA 의 위치가

상위패키지 - 하위패키지 - AA 처럼 되는 경우

호출 방식은 다음과 같다.

package 상위패키지.하위패키지

public class AA ....

전처리 과정 쓰듯 상단에 package 경로를 적어주면 된다.




접근 제한자

public > protected > default > private 순으로 접근 제한이 강화된다.

public : 뚫려있음

protected : 같은 패키지 및 자식(하위) 클래스만 접근 가능

default : 같은 패키지에서 접근 허용

private : 현재 객체 내에서만 허용


그 밖의 Modifier

final
불변 객체를 의미한다.  final로 선언된 객체는 초기화 및 할당을 최초 1회만 수행할 수 있다.

static
인스턴스에 속한게 아닌, 클래스에 속해있는 변수로 여러 클래스가 공유하는 변수를 의미한다.
클래스가 인스턴스화 되기 전 클래스 로딩시점에 이미 생성되고
단 하나의 객체가 공유되는 개념으로 사용된다.

abstract
추상 메소드, 추상 인터페이스를 정의하는 키워드로 abstract method의 경우 하위 클래스에서
반드시 abstract 를 구현해야 한다.

synchronized
스레드 동기화를 위해서 사용되는 키워드로 synchronized로 선언된 메소드는
어떤 스레드가 대상 메소드를 실행중일때 다른 메소드가 접근을 못하도록 한다.
DB로 비유하면 TABLE LOCK의 개념과 유사하다.
메소드나 객체에 synchronized 키워드를 선언할 수 있다.

strictfp
자바에서 float이나 double형은 비트연산의 정밀도가 달라서 부동소수점 연산시
소수점 연산의 에러 가능성이 항상 존재한다.
strictfp 키워드를 클래스나 메소드에 지정하는 경우 부동수소점 숫자의 정밀도를 보장한다.

native (다른 언어 명시)
Interface를 설계 할 때 내부 메소드에 사용되는 키워드이다.
native는 자바가 아닌 다른언어(C나 C++)로 구현할 것이라도 알려주는 키워드이다.
JNI를 이용하여 이기종간 호환을 위해서 사용되는 키워드이다.

transient
Serialize의 반대개념
대상 변수는 직렬화/역직렬화 처리시 제외한다는 키워드이다.
키워드가 지정된 변수는 직렬화를 통한 오브젝트 통신시에 제외되고 처리된다.

volatile
멀티스레드 환경일 경우 각 스레드마다 동일 메모리를 공유하는 것이 아닌
별도 메모리 공간(CPU캐시)에서 변수를 읽어온다.
이런 경우 각 스레드마다 동일한 변수의 값을 다르게 기억할 수 있다.
volatile 키워드는 변수를 읽어 들일 때 CPU캐시가 아닌 컴퓨터의 메인 메모리로 부터
읽거나 쓰도록 처리한다.
volatile은 하나의 스레드에서만 쓰기작업을 하고,
다른 스레드는 읽기작업만 하는 경우 효율적으로 사용할 수 있다.
(synchronized 키워드는 여러 스레드에서 모두 읽기쓰기가 가능하다 = 공유자원)




wrapper 클래스, Boxing / Unboxing

Integer age = new Integer(30);
// 30이 객체처럼 취급됨

Integer aa = 61;
// auto Boxing (new 생성자 없이도 자동으로 boxing처리)

Double avg = new  Double("3.145");

int a = age; // Auto Unboxing

일반적으로 wrapper 클래스 integer의 값을 불러오려면

age.intValue(); 를 사용해야 한다.

출처: https://hyeonstorage.tistory.com/168 [개발이 하고 싶어요]




Getter와 Setter 메소드

클래스 내부의 필드는 private로 직접 변조를 막고
따로 개입이 필요한 경우는 getter나 setter 메소드로
입력 값의 범위에 제한을 두거나 원하는 형태로 가공하여 return하는 것이 좋다.

ex) Getter & Setter

private int speed;

//Getter
public int getSpeed() {
  return speed;
}

//setter
public int setSpeed(int i) {
  this.speed = i;
}

만약 field 타입이 boolean 인 경우 Getter는 get이 아닌 is로 시작하는 것이 관례

boolean 앞에 is로 명명하였던 이유가 이거였구나.




Annotatoin 어노테이션

어노테이션은 일종으 메타데이터라 볼 수 있다.

어노테이션은 다음 과 같이 작성한다.

@AnnotationName

어노테이션의 용도
1. 컴파일러에게 코드 문법 에러를 체크하도록 정보를 제공
2. 소프트웨어 개발 툴이  빌드나 배치 시 코드를 자동으로 생성할 수 있도록 정보를 제공
3. 실행 시 (런타임 시) 특정 기능을 실행하도록 정보를 제공

영향을 미치는 주석같다?

대표적으로 @Override 어노테이션이 있다.

메소드 사용 시 @Override를 선언하면 컴파일러가 오버라이드 검사를 한다.

즉 실행 시 클래스 역할을 정의하기도 함



객체타입 확인 (instanceof)

슈퍼클래스와 서브클래스를 혼재해 사용하다 해당 객체가 부모인지 자식인지 혼동할 수 있다.
이 때

boolean result = 판별대상 객체 instanceof 비교 타입

좌항이 우항과 타입이 일치하면 true, 다르면 false를 반환한다.




추상클래스

인터페이스

둘 다 메소드 오버라이드 할 경우 @Override Annotation 가급적 붙여줄 것!


(p.351 인터페이스 구현 생략)




예외처리, 예외 클래스

에러(error) : 하드웨어의 오동작 또는 고장으로 발생한 실행 오류
예외(exception) : 사용자 및 코딩 오류...

예외는 두 가지 종류가 있다.
- 일반 예외 (exception) : 컴파일러 체크 예외
  (컴파일 과정에서 예외처리 코드가 필요한지 검사, 예외 처리가 없으면 컴파일 오류 발생)

- 실행 예외 (runtime exception) : 컴파일 과정에서 예외처리 코드를 검사하지 않는다.
  컴파일러가 검사하지 않기 때문에 오로지 개발자의 판단에 의해 예외처리 코드를 삽입해야 함.
  만약 실행 예외상황에 대한 대처 코드가 없을 경우 해당 상황 발생 시 프로그램은 바로 종료된다.


먼저 자주 발생하는 실행 예외의 경우

NullPointerException

null 값을 갖는 참조 변수를 참조 했을 때 출력되는 오류
객체가 없는데 객체를 요청하여 발생하는 사례이다.

ex) String data = null;
    System.out.println(data.toString());

    이렇게 null 상태인 data변수에 toString메소드를 요청하면

    NullPointerException 오류가 출력된다.



  ArrayIndexOutOfBoundsException

  배열에서 인덱스 범위를 초고하여 사용하는 경우 발생  (지정 범위 초과 오류)

  그러나 배열에 올바른 값이 들어있지 않은 경우에도 발생할 수 있다.

  ex) String data1 = arr[0];
      String data2 = arr[1];

      System.out.println("arr[0] : " + data1);
      System.out.println("arr[1] : " + data2);

      위 코드를 실행하면 ArrayIndexOutOfBoundsException 오류가 출력된다.

      이유는 arr에 적절한 매개변수가 들어가 있지 않기 때문


이와 같은 오류를 방지하기 위해

배열의 길이를 사전에 조사하거나 올바른 매개변수가 들어있는지 조사하는 코드를

삽입하는 것이 좋다.




NumberFormatException

문자열 데이터를 숫자로 변경하면서 숫자 값 이외의 문자열이 들어있으면

당연히 정상적으로 변환되지 않는다.

이 때 발생하는 오류가 NumberFormatException 이다.




ClassCastException

올바른 관계의 타입 변환(Casting)이 아니면 ClassCastException 오류가 출력된다.

상속관계 점검을 위해 instanceof 연산자를 사용할 것




try-catch-finally 블록을 통한 예외처리 코드 작성

try{
  예외 발생 가능 코드
} catch (예외처리 할 클래스 e) {
  예외 처리 코드
} finally {
  프로그램 지속 (안 쓰는 경우도 많음)
}


if문을 여러번 사용하듯이 catch문도 다중 선언 가능함

다중 catch문을 작성 시 주의점은 상위 예외 클래스가 하위 예외 클래스보다 아래에 위치해야 함

try 블록에서 예외 발생 시 catch 블록은 위에서부터 순서대로 검색하기 때문이다.

하위 -> 상위 (아래부터 위로)


ex)

try {
  ArrayIndexOutOfBoundsException 발생

  NumberFormatException 발생

  기타 exception 발생
}

catch (ArrayIndexOutOfBoundsException e) {
  대응 코드
}

catch (exception e) {
 대응 코드
}


이처럼 catch문을 여러개 사용할 수도 있지만

2가지 예외 상황에 같은 대응처리를 한다 가정을 해보자.

그렇다면 다음과 같이 작성하면 된다.

catch (ArrayIndexOutOfBoundsException | NumberFormatException e) {
  대응 코드
}

이처럼 예외 목록에 논리 연산자 사용이 가능함




resource 닫기

try-with-resources

예외 발생 여부와 상관없이(!) 사용했던 리소스 객체 (I/O stream, server socket, 등등 각종 채널 모두!)

close() 메소드를 호출하여 안전하게 닫아줌


사용하기 위해서는 java.lang.AutoCloseable 인터페이스를 implements해야 함

implements AutoCloseable

예제코드 close_resource_example.java 참조





예외 떠넘기기

throws

throws는 문제가 발생할 것으로 추정되는 메소드 뒤에 후술한다.

ex)

 public void method1() {

      try {

        method2();
      } catch (ClassNotFoundException e) {

        // 예외처리 코드
        System.out.println("클래스가 존재하지 않습니다.");
      }
 }

 public void method2() throws ClassNotFoundException {

    Class clazz = Class.forName("java.lang.Sting2");
 }


method1에서 호출되는 method2를 선언하면서 뒤에 throws를 후술한다.

이러한 경우 method2를 실행하며 발생한 예외가

method2를 호출한 method1의 try catch 문으로 처리를 한다.

이것이 왜 중요한가??

자바 프로그램을 개발하며 여러 API를 사용하는 과정에서 jdk에서 제공해주는 메소드의 경우

jdk document에서 method 소개 뒤에 throws 예외처리 구분이 있다면

그에 대한 대응을 만들어주어야 사용할 수 있다.


어떤 method의 throws 예외 구문이 있다면 try-catch를 후술하여

예외처리 코드를 작성해주어야 한다.

그러나 throws 뒤의 예외가 runtime exception이라면 try-catch를 사용하지 않아도 된다.


요약하자면 각종 api에서 참조한 에러를 내가 확인하고 대응하기 위해

jdk api 에서 불러온 method에서 발생한 예외를 내가 작성한 코드 안으로 예외를 떠넘겨야

사용자가 확인이 가능하다.





사용자 정의 예외 선언

사용자 정의 예외는 컴파일러가 체크하는 일반 예외로 선언 할 수도 있고

컴파일러가 체크하지 않는 실행 예외로 선언 할 수도 있다.

method처럼 사용자가 선언하며 생성자도 필요함.

ex)

public class exampleException extend Exception (실행 예외 RuntimeException 도 가능함) {
    public exampleException() {}  // 생성자 선언
    public exampleException(String message) { // 에러 스트링을 부모 클래스로 전달 (떠넘기기)
        super(message);
    }
}


호출 시 상위 클래스의 생성자를 호출하여 String 으로 된 예외 메시지를 넘겨준다.



인위적으로 예외를 발생시켜 처리 할 수도 있다.

throw new xxxException();

또는

throw new xxxException("메시지");

물론 사용 후 try-catch 블록으로 처리해주어야 함

userThrows.java 예시를 보자.



위에서 계속 다룬 try-catch-finally 블록을 보면

catch 에서 exception 뒤에 e를 붙인다.

이는 'e' 라는 예외 객체를 생성하는 것인데

e.getMessage(); 내장 메소드를 통해 예외 정보를 담은 메시지를 콘솔에 출력하거나

e.printStackTrace(); 메소드를 통해 해당 예외가 어느 지점에서 발생했는지

콘솔에 출력해주어 편하게 찾을 수 있다.

기타 예외처리 예제 참조





Java API

API = Library

자바 API를 찾아보기 쉽게 정리된 API document 링크를 첨부함

https://docs.oracle.com/en/java/javase/12/docs/api/index.html





객체 소멸자 .finalize()

참조하지 않는 배열이나 객체는 gc가 힙 영역에서 자동으로 소멸시킨다.

gc는 해당 객체를 소멸시키기 직전에 소멸자 finalize()를 실행시키는데

이때 마지막으로 사용한 자원 (연결, 파일 등)을 닫고 싶거나,

별도의 처리를 가하고 싶다면 다음과 같이 오버라이드하여 사용할 수 있다.

ex)

@Override
protected void finalize() throws Throwable {
  System.out.println(no + "번 객체의 finalize() 실행.");
}

또는 대상 객체를 null로 만들어 버린 다음에

System.gc(); // gc 호출

gc를 강제로 호출하여 소멸시키는 방법이 있다.




동적 객체 생성




멀티 스레드

멀티 프로세싱 vs 멀티 스레딩
: 전자는 여러 애플리케이션, 후자는 하나의 애플리케이션에서 여러 스레드 흐름 발생

멀티 스레드 애플리케이션을 개발하려면 먼저 몇 개의 작업을 병렬처리 할 것인지 정하고

각 작업별 스레드를 생성해야 한다.


작업 스레드 역시 자바에서 지원하는 thread 클래스를 객체화 하여 사용한다.

먼저 목표 함수(프로그램)을 실행할 매개로 갖는 thread를 생성한다.

Thread thread = new Thread(Runnable target);

// Runnable은 작업 스레드가 실행할 수 있는 코드를 가지고 있는 객체이다.

class Task implements Runnable {
  public void run() {
    //thread가 실행할 코드
  }
} // Task 객체 틀 생성

Runnable task = new Task();
// 생성한 Task 객체를 Runnable 타입 task로 선언

Thread thread = new Thread(task);
// 선언한 task를 thread 객체의 파라미터로 넣고 생성


요렇게 각 과정을 따로 작성해도 되지만 아래처럼 통합해도 된다.

Thread thread = new Thread( new Runnable() {
  public void run() {
    // thread가 실행할 코드
  }
});

thread 클래스 선언부 파라미터 구간에서 코드 작성해도 됨


물론 파라미터부에 람다식으로 작성해도 문제는 없다.

다만 람다식 특성상 디버깅이 어렵고 무명으로 선언되기에 재귀에 사용하기 까다롭기 때문에

가급적 사용을 자제하라는 글도 봄...


thread객체는 생성하면 바로 실행되는 것이 아니라 다음과 같이 실행 메소드를 사용해야 한다.

ex)

thread.start();

start() 메소드가 호출되면, 작업 스레드는 매개값을 ㅗ바든 Runnable의 run() 메소드를

실행한다.


beep 음과 콘솔창에 알림을 동시에 출력하는 프로그램을 예시로 들어보겠다.

먼저 메인 스레드만 이용한 경우이다.

    // 메인 스레드만 이용한 경우

    import java.awt.*; // beep 소리 출력 메소드에 사용

    public class BeepPrintExample1 {
      public static void main(Strint[] args) {
        Toolkit toolkit = Toolkit.getDefaultToolkit();
        // toolkit 객체 얻기 (비프음 메소드 호출에 필요)

        for(int i=0; i<5; i++)  {
          toolkit.beep();
          try {Thread.sleep(500);} catch(Exception e) {}

        } // for end : 0.5초의 딜레이를 가지고 beep음 출력

        for(int i =0; i<5; i++) {
          System.out.println("beep!");
          try {Thread.sleep(500);} catch(Exception e) {}
        } // for end : 0.5초의 딜레이를 가지고 beep 텍스트 콘솔창에 출력

      } // main end
    } // class end


    // 이렇게 메인 스레드에 작성을 하면 beep음만 0.5초 딜레이로 5번 출력 후
    // 콘솔창에 beep 텍스트가 0.5초 딜레이로 5번 출력 된다.

    // 즉 출력과 소리가 동시에 일어나지 않는다.



여기서 beep 음 출력 파트를 별도의 thread에 담아 실행해보자.

    // Beep 소리 출력 task 분리

    public class BeepTask implements Runnable {
      public void run() {
        Toolkit toolkit = Toolkit.getDefaultToolkit();
        for (int i =0; i<5; i++) {
          toolkit.beep();
          try{thread.sleep(500);} cathc(Exception e) {}
        }// for end
      } // run end
    } // class end


그리고 main thread를 다시 작성


    // BeepTask (소리 출력 Task 분리)

    public class BeepPrintExample2 {
      public static void main(String[] args) {
        Runnable beepTask = new BeepTask();
        Thread thread = new Thread(beepTask);

        for (int i=0; i<5; i++) {
          System.out.println("띵");
          try {Thread.sleep(500);} catch (Exception e) {}

        }
      }
    }


Thread의 이름 설정

생성한 스레드는 자동으로 Thread-n 형식의 이름을 갖는다.

main 스레드는 예외로 main이름의 thread를 갖게됨.

번호(n) 대신 스레드의 이름을 따로 짓고 싶다면 다음과 같이 setName 메소드를 사용




ex)
thread.setName("스레드 이름 정하기!");

반대로 스레드의 이름을 알고 싶다면

thread.getName();

두 메소드는 Thread의 인스턴스 메소드이므로 당연히 스레드 객체의 참조가 필요함

만약 현재 실행중인 스레드 객체의 참조 포인트가 없다면

정적메소드 currentThread() 로 현재 사용중인 스레드 이름을 얻을 수 있다.




ex) 현재 실행중인 스레드 읽어오기

Thread thread = Thread.currentThread();




여러 스레드를 동시에 운용하는 예제를 보자.

thread_name.java 참조

// 스레드의 구분을 위한 이름 설정 및 운용 예제

// 구성 요소 : ThreadNameExample.java, ThreadA.java, ThreadB.java


    public class ThreadNameExample {
      public static void main(String args[]) {
        Thread mainThread = Thread.currentThread();
        System.out.println("프로그램 시작 스레드 이름 : " + mainThread.getName());

        ThreadA threadA = new ThreadA();
        System.out.println("작업 스레드 이름 : " + threadA.getName());
        threadA.start();

        ThreadB threadB = new ThreadB();
        System.out.println("작업 스레드 이름 : " + threadB.getName());
        threadB.start();

      } // main end
    } // class end


그렇다면 스레드간의 우선순위는 어떻게 될까?


멀티 스레드는 동시성 (concurrency) 또는 병렬성 (parallelism)으로 실행됨

동시성 : 멀티작업을 위해 하나의 코어에서 멀티 스레드가 번갈아가며 실행되는 성질
(하나의 코어에서 여러 스레드를 굴린다.)

병렬성 : 멀티작업을 위해 멀티 코어에서 개별 스레드를 동시에 실행하는 성질
(여러 코어에서 여러 스레드를 굴린다)

스레드 스케줄링에 의해 스레드들은 짧은 시간에 번갈아가며 run() 메소드 안의

코드를 실행한다.



자바의 스레드 스케줄러는 우선순위 방식과 라운드 로빈 방식(순환 할당, time token)을 사용한다.

여기서 사용자가 개입할 수 있는 부분은 우선순위를 이용한 방식이다.

Thread 객체의 setPriority(1~10) 메소드를 통해 스레드의 우선순위를

수동으로 할당할 수 있다.

예시처 1~10 까지의 값을 부여할 수도 있으나

Thread 클래스 내부의 우선순위용 상수를 사용할 수도 있다.

*** 1의 우선순위가 가장 낮고 10의 우선순위가 가장 높게 부여된다.

ex)
thread.setPriority(Thread.MAX_PRIORITY);

Thread.MAX_PRIORITY : 10

Thread.NORM_PRIOIRTY : 5

Thread.MIN_PRIORITY : 1

운영체제 수업에서 배운 것 처럼 같은 우선순위의 작업은 그들간 라운드 로빈 방식을 취한다.


다음 우선순위를 설정한 스레드 예제를 참고해보자.

PriorityExample.java 참조

// 스레드 우선순위 부여 예제

// CalcThread.java 참조

    publicc class PriorityExample {
      public static void main(String args[]) {
        for (int i =0; i<=10; i++) {
          Thread thread = new  CalcThread("thread" + i);
          if (i !=10) {
            thread.setPriority(Thread.MIN_PRIORITY);
            // 가장 낮은 우선순위 설정
          } else {
            thread.setPriority(Thread.MAX_PRIORITY);
          } // if extend

          thread.start();
        }
      }
    }





공유객체를 통한 동기화 메소드, 동기화 블록

싱글 스레드 프로그램과 달리 멀티 스레드 프로그램은 여러 스레드가 객체의 자원을 공유하므로

자원 사용에 있어 각별히 신경써야 한다.

A, B 두 스레드가 하나의 필드를 공유한다고 가정해보자.

A가 해당 필드를 수정 도중에 B가 그 필드에 접근한다면

B는 A가 수정도중인 자료를 참조하게 되므로 사용할 수 없는 값이 나오게 된다.




공유 객체 예제


동기화 메소드 & 동기화 블록

C의 mutex 함수처럼 자바에도 스레드간 동시에 공유자원을 참조하지 못 하도록 잠금 기능이 있다.

자바는 critical section을 지정하기 위해 synchronized 메소드와 동기화 블록을 제공한다.

자바는 스레드가 동기화 메소드나 블록에 접근하면 객체에 잠금을 걸어 다른 스레드가

임계영역에 접근하지 못 하도록 제한한다.

동기화 객체에서 스레드가 작업을 마치고 실행 종료를 하면 잠금이 풀린다.




* 예를 들어 스레드1이 syncronized가 붙은 객체를 사용중일 때 스레드2는

syncronized가 붙은 다른 모든 메소드나 필드에 접근할 수 없다.

스레드 1의 syncronized 에서 실행중인 작업이 종료될 때 까지 일반 메소드만 접근 가능함




동기화 메소드는 메소드 선언부에 syncronized 키워드를 붙여 선언할 수 있다.

인스턴스와 정적 모두 선언 가능함.

ex) 임계영역 메소드 선언

public syncronized void method() {
  임계영역 코드;
}


ex) 일부만 임계영역으로 지정

public void method() {
  // 여러 스레드가 접근 가능한 영역

  syncronized(공유객체) {  // 대상이 자신이라면 this 사용 가능
    // 임계영역
  }

  // 여러 스레드가 접근 가능한 영역
}





스레드 상태 확인 메소드 getState()

getState() 메소드는 스레드 상태에 따라 몇 가지 열거 상수를 반환한다.

수동으로 할 경우

Thread.State state = 목표스레드.getState();

다음과 같이 담아서 사용 가능

* 스레드 상태 폴더 참조


스레드 상태 제어

yield() : 의미없는 작업 수행 시 다른 스레드에게 실행 순서 양도

stop() : 스레드 정지 수단이나 강제적이므로 stop보단 run을 빨리 끝낼 방안을 사용하자

join() : 다른 스레드의 종료를 기다림

두개의 스레드 A와 B가 있다 가정

 [threadA.java]
 threadB.start();
 threadB.join(); // thread A가 threadB의 결과를 받기 위해 연산이 끝날 때 까지 대기

 // 계산 결과 값을 받아 사용하는 경우에 다음과 같은 방식을 사용


wait(), notify(), notifyAll() 은 공유객체를 돌아가며 사용할 때

사용하는 메소드이므로 synchronized 메소드나 블록에서만 호출 가능하다.



위의 wait_notify를 이용하여 데이터를 생산하는 스레드와 소비하는 스레드의 예시를 보자

* Producer_Consumer_Example.java 참조



스레드의 안전한 종료 Stop플래그, interrupt();

stop 플래그가 아닌 stop() 메소드는 스레드를 즉시 졸료시키기 때문에 좀비 자원들이 남게 된다.





stop 플래그 예시

ex)

public class XXXThread extends Thread {
  private boolean stop; //stop 플래그 필드

  public void run() {
    while(!stop) {            // stop이 true가 되면 루프문 탈출 -> run() 메소드 종료
      // 스레드가 반복 실행하는 코드;
    }

    // 스레드가 사용한 자원 정리
  }
}

* StopFlagExample.java 참조

stopflag 는 현재 다루고 있는 스레드를 종료시킬 수 있으나

일시정지 상태인 스레드는 정지시킬 수 없다.


이처럼 일시정지 상태인 스레드를 종료할 때 interrupt 메소드를 사용한다.

interrupt 메소드는 runnable(실행대기)이거나 execution(실행)상태의 스레드에 사용할 수 없다..





Interrupt()를 사용한 스레드 상태제어

A스레드에서 B스레드로 Interrupt Exception을 유도하기 위해선 B스레드가 일시정지 상태가

되어야 한다.


interrupt 메소드가 일시정지가 아닌 상태에서 호출되면 그 다음 일시정지가 될 경우에

자동으로 호출된다.


스레드 실행 중 인터럽트 개입이 필요한 경우 thread.interrupt(); 메소드나 isInterrupt();

메소드를 참조하여 불 대수 값을 얻어내 플래그를 세우도록 하자.



데몬 스레드를 응용한 자동 저장 기능을 갖춘 스레드의 간단한 예시를 보자

* DaemonExample.java 참조






스레드 그룹

관련된 스레드를 묶어서 운용

계층적으로 하위 스레드 그룹을 가질 수 있음

System 그룹에서 JVM 운용에 필요한 스레드와 메인 스레드를 자동으로 생성한다.


스레드는 반드시 스레드 그룹에 속해있어야 하며

자신을 생성한 스레드와 같은 그룹에 소속됨


스레드 그룹 이름 얻기

ex)

ThreadGroup group = Thread.currentThread.getThreadGroup();

또는

String GroupName = group.getName();




JVM이 생성한 스레드를 살펴보고 주 스레드와 데몬스레드 관찰

* groupExample.java 에서 다음과 같은 결과를 얻었다.


for(Thread thread : threads) {
			System.out.println("Name : " + thread.getName() + ((thread.isDaemon()?"(데몬)":"(주)")));
		}


    Name : Signal Dispatcher(데몬)
    Name : Common-Cleaner(데몬)
    Name : Reference Handler(데몬)
    Name : main(주)
    Name : Attach Listener(데몬)
    Name : Finalizer(데몬)
    Name : AutoSaveThread(데몬)


이제 스레드의 역할은 파악하였다. 소속 그룹을 확인해보자



for(Thread thread : threads) {
			System.out.println("Name : " + thread.getName() + ((thread.isDaemon()?"(데몬)":"(주)")));
			System.out.println("\t" + "소속그룹 : " + thread.getThreadGroup().getName());
			System.out.println();
		}


  Name : Signal Dispatcher(데몬)
	  소속그룹 : system

  Name : Common-Cleaner(데몬)
  	소속그룹 : InnocuousThreadGroup

  Name : Reference Handler(데몬)
  	소속그룹 : system

  Name : main(주)
  	소속그룹 : main

  Name : Attach Listener(데몬)
  	소속그룹 : system

  Name : Finalizer(데몬)
  	소속그룹 : system

  Name : AutoSaveThread(데몬)
  	소속그룹 : main





스레드 그룹 선언

스레드를 선언 할 때 2가지 방법이 있었다.

ex)

1.

Thread t = new Thread (new Runnable() {

  @Override
  public void run() {
    // 실행 코드
  } // run end

} ) // Thread t end



2.

class t extends Thread {

  public void run() {
    // 실행 코드
  } // run end
} // t end


여기서 전자의 경우

Thread t = new Thread(ThreadGroup group, Runnable target);
// 초기 파라미터로 지정



후자의 경우

class t extends Thread {

  public t (ThreadGroup group, String threadName) {
    super(group, threadName); // 상속 형식으로 지정
  }

  public void run() {}
}




스레드 그룹 통제

그룹 단위로 스레드 통제 메소드 참조

activeCount()
activeGroupCount()
checkAccess()
destory()
getMaxPriority()
setMaxPriority(int pri)
.
.
.
inturrept()



스레드 그룹에 interrupt() 명령을 호출하면

그룹 내 모든 하위 스레드에 interrupt() 명령이 전달된다.







스레드 풀 (Excutor Service)


자원의 한계로 스케쥴을 짜서 스레드를 운용할 필요가 있다.

따라서 작업 큐와 스레드 풀을 사용함


자바는 ExecutorService 인터페이스와 Executor 클래스를 통해

스레드 풀 관련 패키지를 재공한다.

java.util.concurrent 패키지에서 제공.


Thread pool = ExecutorService 객체

ExecutorService 내부에는 작업 큐와 스레드가 존재한다.

서버 애플리케이션에서 필수로 사용하므로 향후 네트워크 파트를 대비햐여 잘 숙지할 것!



초기 스레드 수 : 스레드 풀을 초기 생성 시 기본적으로 들어가있는 스레드 수

코어 스레드 수 : 스레드 풀에 스레드가 전개되었을 때 사용되지 않는 스레드를 제거하며

                제거하지 않고 최소로 유지하는 스레드 수

최대 스레드 수 : ...



newCachedThreadPool()

초기 스레드 수 : 0, 코어 스레드 수 : 0, 최대 스레드 수 : Integer의 최대 값 만큼

이론적으로 Int값의 한계만큼 가능하나 운영체제가 가진 메모리 상황에 따라 달라짐

추가된 스레드가 60초 이상 아무런 작업도 하지 않으면 해당 스레드를 종료하고 풀에서 제거함


ex) ExecutorService threadpool = Executors.newCachedThreadPool(); // 스레드 풀 객체는 정적메소드



newFixedThreadPool(int n Threads) // 매개 변수로 최대 스레드 개수 int 값 부여

CachedThreadPool 과는 달리 유휴상태 스레드가 제거되지 않는다.

코어 스레드 개수 : n, 최대 스레드 수 : n

ex) 매개변수로 cpu가 가지고 있는 코어의 수를 전달

ExecutorService threadPool = Executors.newFixedThreadPool(
  Runtime.getRuntime().availableProcessors() // cpu의 코어 수 획득
); // threadPool end



ex) 세부사항 부여 : 코어 스레드 3, 최대 스레드 100개인 스레드풀 생성

ExecutorService threadPool = new ThreadPoolExecutor(

3,    // 코어 스레드 개수
100,  // 최대 스레드 개수
120L, // 놀고 있는 시간 제한
TimeUnit.SECONDS, // 놀고있는 시간 단위  (120L, SECONDS : 120초)
new SynchronuosQuewe<Runnable>() // 작업큐
)



스레드 풀 종료

* 스레드 풀의 스레드는 기본적으로 데몬 스레드가 아님

따라서 main 스레드가 종료되더라도 스레드풀의 스레드는 작업을 계속 처리한다.

따라서 애플리케이션을 종료하기 위해서는 스레드풀의 모든 스레드를 종료시켜야 한다.


스레드 풀 종료 메소드에

shutdown() : 작업큐와 현재 작업중인 모든 스레드의 작업을 마친 뒤 종료

shutdownNow() : 현재 처리중인 스레드에 interrupt()를 걸어 작업 중지를 시도하고

                스레드 풀을 종료함. 큐에 남은 미처리 작업목록을 반환함

awaitTermination(long timeout, TimeUnit unit) : 시간과 단위를 매개변수로 준다.

이렇게 지정된 시간 내에 끝난 작업은 True로 처리하고 시간 내 끝내지 못한 작업은

인터럽트를 걸어 중지시키고 False를 반환한다.



가급적이면 작업을 안전하게 종료시킨 뒤에 애플리케이션을 닫는 shutdown()을 사용해야 함





작업 생성

작업은 Runnable과 Callable 클래스 두 가지가 있다.

Runnable 객체는 리턴 값이 없고 Callable 객체는 리턴값이 있는 것이 대표적인 차이

위에서 많이 다루었듯이

Runnable 클래스는 다음과 같다.

    Runnable task  = new Runnable() {

      @Override
      public void run() {
        // 스레드가 처리할 작업 내용
      }
    }

run 메소드 내부의 코드만 실행하고 끝난다.

즉, 작업이 끝나며 별 다른 리턴 값이 발생하지 않는다.


Callable 클래스는 제네릭 타입으로 결과 값 타입을 지정해주어야 한다.

* 리턴 자료형 String 예시

Callable<T> task = new Callable<T> {
  @Override
  public T call() throws Exception {
    //스레드가 처리할 작업 내용
    return T;
  }
}





작업 처리 요청

ExcecutorService의 작업 큐에 Runnable 또는 Callble 객체를 넣는 행위


execute(Runnable command) : 작업 큐에 넣을 Runnable 객체를 매개변수로 받는다.

작업 처리 결과를 받지 못 하는 것이 특징.
(결과 값이 없는 작업을 큐에 넣을 때 사용)


submit(Runnable task) : 작업 결과를 얻을 때 사용, Future<V> 지정 타입으로 결과 반환



작업 처리 도중에 예외가 발생한 경우

execute(); 메소드의 경우 스레드가 종료되며 해당 스레드는 제거된다.

따라서 스레드풀은 다른 작업 처리를 위해 새로운 스레드를 생성함.


submit(); 메소드의 경우 예외가 발생한 스레드가 종료되지 않고 다음 작업을 위해 재사용.



스레드 생성에 소모되는 자원 때문에 가급적 submit() 메소드를 사용하는 것이

오버헤드를 줄이는데 도움이 된다.




블로킹 방식의 스레드 풀

스레드 풀 예제 Execute_VS_Callable_Example.java 에서

작업 결과를 반환하지 않는 실행 객체 예시를 보았다.

Execute 메소드와 달리 submit 메소드는 연속으로 실행할 때 예외 오류가 출력되지 않았는데

이러한 경우 해당 작업이 정상적으로 종료되었는지 확인하기 위해 Future 객체가 필요하다.


다음 예시를 참조하여 리턴 값이 없는 스레드의 실행 결과 통보 방법을 보자


* NoResultExample.java



		Future future = executorService.submit(runnable);
		// future 객체에 executorService 스레드 풀에서 submit 옵션으로 runnable 객체를 돌린 결과를 반환한다.
		// 아래에 future.get() 메소드를 선언하였으므로 runnable의 작업이 완료 될 때까지 main 스레드는 블로킹 상태로 대기한다.


		try {
			future.get();
			System.out.println("[작업 처리 완료]");
		} catch (InterruptedException e) {

			// Interrupt() 메소드 호출 시 해당 예외처리 실행
			System.out.println("[인터럽트 예외 발생함] " + e.getMessage());
			e.printStackTrace();
		} catch (ExecutionException e) {

			// 작업 처리 도중 예외 발생 시 해당 예외처리 실행
			System.out.println("[실행 예외 발생함] " + e.getMessage());
			e.printStackTrace();
		}


지금과 같은 실습환경에서는 main 스레드에서 future.get(); 메소드를 실행시켜도 문제가 없지만

안드로이드나 다른 UI를 다루는 스레드에서 get(); 메소드를 실행시키면 시스템이 중단되는 것 처럼 보이므로

주의해서 사용해야 한다.





* 리턴값이 있는 작업 완료 통보

ex)

  Callable<T> task = new Callable<T>() {
    @Override
    public T call() throws Exception {
      // 스레드가 처리할 작업 내용
      return T;
    }
  };

  Future<T> future = executorService.submit(task);

  try{
    T result = future.get(); // 위에서 끝난 스레드 결과를 T result 객체에 저장
  } catch (InterruptedException e) {
    // 작업 처리 도중 스레드가 interrupt 될 경우 실행할 코드
  } catch (ExecutionException e ) {
    // 작업 처리 도중 예외가 발생한 경우 실행할 코드
  }


자세한 내용은 ResultByCallableExample.java 참조




작업처리 결과를 외부 객체에 저장 & 분산처리 응용

여러 스레드에 연산을 분배하고 외부 객체에 저장한 결과를 취합

다음 예제 참조

ResultByRunnableExample.javase


(thread pool 4 이어서 진행)

작업 완료순으로 통보 받기

작업 요청 순서대로 작업 처리가 완료되는 것은 아님.

작업 결과를 순차적으로 처리 할 필요가 없다면 완료된 것부터 바로 이용



CompletionService 에서 poll() 과 take()메소드를 제공함

poll()은 get과 비슷하게 완료된 작업의 Future를 가져온다.

다만 get()처럼 블로킹 상태로 대기하는 것이 아니라 완료된 스레드가 있다면

해당 스레드의 결과를 큐에 입력 순서와 상관없이 가져온다.

time 인자를 추가로 입력 할 경우 완료된 작업이 없다면 timeout 제한시간까지 블로킹됨



take() 메소드는 완료된 작업이 없다면 있을 때까지 블로킹된다.

submit(Callable<V> task)

submit(Runnable task, V result)

submit 메소드는 ExecutorService의 응용 사례와 같다.



CompletionService 객체는 먼저 ExecutorService 스레드풀 객체를 생성해야 사용 가능함

ex)

ExecutorService thread_pool1 = Executor.newFixedThreadPool(
    Runtime.getRuntime().availableProcessors()
);

CompletionService<V> completion_pool = new ExecutorCompletionService <V> (
    thread_pool1 // 작업을 가져올 스레드풀
);

// CompletionService 객체에 스레드 풀을 저장

completion_pool.submit (Callable<V> task);

completion_pool.submit (Runnable task, V result);

// poll(), take() 메소드는 CompletionService 객체로 불러온 submit으로만 사용 가능



* take() 메소드 역시 get() 메소드처럼 작업이 완료 될 때까지 블로킹 되므로

UI 스레드에서 호출주의!


작업 완료 순서로 결과를 출력하는 예제는

CompletionServiceExample.java 참조




작업 완료 통보는 블로킹과 콜백 두가지 방법이  있다.

블로킹 방식은 Future 객체를 이용

콜백 함수는 해당 메소드 호출


콜백 방식은 메인 스레드가 스레드풀에게 작업 요청을 한 뒤에도 계속 자신의 작업을 진행함

진행 중 요청한 작업이 완료되면 콜백 메소드 실행



콜백 방식 역시 콜백 메소드를 사용하기 위해 콜백 객체를 생성해야 한다.

ex)

CompletionHandler<V, A> callback = new CompletionHandler<V, A> ()

V는 반환 결과 형식, A는 참조 객체 형식

callback 객체의 메소드는 completed(V result, A attachment), failed(Throwable exc, A attachment)

completed( 결과 객체, 참조 객체);

failed( 예외 객체, 참조 객체);



콜백 객체를 미리 지정해 놓고 (completed, failed 포함) 작업객체 (Runnable, Callable) 에서 사용

try-catch 문에서 성공 시 completed(), 예외 발생 시 failed() 메소드 연결



콜백 메소드는 실행 주체는 메인 스레드가 아닌 스레드풀의 스레드가 실행

java FX나 Android App에서 UI 를 생성하거나 변경하는 스레드를 콜백함수 안에 작성하면 에러발생!

= 상시 기동해야 할 코드를 스레드에서 부분 실행하기 때문에 정상적으로 실행되지 않는다.



** implements와 extends의 차이점

상위 객체의 정보를 상속받은 하위 객체를 생성할 때 경우에 따라 extends 나 implements를 구분하여 쓴다.

왜 그럴까?

먼저 extends는 부모에서 선언/정의를 모두 하며 자식은 부모의 메소드 및 변수를 바로 사용할 수 있음

반면 implements는 (interface 구현) 부모 객체가 선언만 하며 하위 내용은 자식이 오버라이딩 해야 함

추가로 abstract가 있다. (추상 메소드)









Generic type


제네릭 타입, 멀티 타입 파라미터, 제네릭 메소드, 제한된 타입 파라미터,
와일드카드 타입, 제네릭 타입의 상속과 구현


제네릭 타입을 왜 사용할까?

Generic은 타입을 파라미터화 해서 컴파일시 구체적인 타입이 결정되도록 하는 것

컬렉션, 람다식, 스트림, NIO 에서 많이 사용됨


컴파일 시 미리 타입을 강조하여 에러를 사전에 방지함


ex) List list = new ArrayList();
    list.add("hello");
    String str = (String) list.get(0);

    List <String> list = new ArrayList <String> ();
    list.add("hello");
    String str = list.get(0);

    * 아래 코드의 경우 list 객체가 받는 데이터를 <String>으로 고정함

    따라서 아래 str에서 바로 가져올 수 있다.





제네릭 타입은 타입을 < > 안에 입력하는 파라미터로 가진 클래스와 인터페이스를 말한다.

선언시 클래스 / 인터페이스 이름 뒤에 "< >" 부호가 붙는다.

public class 클래스명 <T> {...}

public interface 인터페이스명 <T> {...}




제네릭 타입을 지정하여 타입을 확고히 명시함으로 타입변환을 최소화 (타입변화에 대한 오버헤드 최소화)


* 최상위 객체 Object type

ex) public void set(Object object) {this.object = object; }
    // 어떠한 객체도 받아들일수 있다.

    public Object get() {return object;}
    // Object 타입 반환

    box.set("hello"); // Object 타입으로 저장

    String str = (String) box.get();
    // 반환받을땐 필요한 타입을 명시해준 뒤 받으면 됨




물론 타입변환이 많을 수록 성능 낭비가 크므로 타입을 한정해놓고 사용하는 것이 좋다.




제네릭 타입을 이용하여 클래스를 선언하면 이후 해당 클래스 객체를 생성할 때 타입 파라미터를 변경하여

상속받는 것 처럼 이용할 수 있다.

ex)

  * 클래스 (설계)선언땐 타입 파라미터로 작성 가능

    public class Box <T> {
      private T t;
      public  get() { return t; }
      public void set(T t) { this.t = t;}
    }

  위와 같이 타입 파라미터로 클래스를 정의하고


    Box <String>  box = new Box<String> ();
    public class Box<String> {
      private String t;
      public void  set(String t) {this.t =t;}
      public T get() {return t;}
    }

    Box <Integer>  box = new Box<Integer> ();
    public class Box<Integer> {
      private Integer t;
      public void  set(Integer t) {this.t =t;}
      public T get() {return t;}
    }

  해당 제네릭 타입 클래스 객체를 선언 시 타입 파라미터 자리에 원하는 타입을 지정하여 응용 가능




    Box<String> box = new Box<String>();

    Box<Integer> box = new Box <Integer>();
    box.set(6);
    int value = box.get();


  요렇게 생성시 타입 파라미터 자리에 적절한 타입을 배치해서 생성하면

  컴파일러가 알아서 타입 파라미터를 치환해준다.


더 자세한 제네릭 타입 사용 예시는 Box.java, BoxExample.java 참조




멀티 타입 파라미터

타입 파라미터를 여러개 사용해서 선언 가능

ex)

    public Box <K, V> {

    private K k;
    private V v;

    타입별 getter, setter
    }



자바 7 이상부터는 타입 파라미터를 중복해서 사용할 필요가 없다.

Product<Tv, String> product = new Product <> (); // 생성자 입력부에서 "<>"만 써도 컴파일러가 유추함



제네릭 메소드에

제네릭 메소드는 매개변수 타입과 리턴 타입 파라미터를 갖는다.


public <타입 파라미터> 리턴 타입   메소드명(매개변수,...) {...}

public <T> Box<T> boxing(T t) {...}



제네릭 메소드 호출도 생성자 호출과 비슷하게 컴파일러에서 타입을 유추해준다.

1) Box <Integer> box = <Integer> boxing (100);

2) Box <Integer> box = boxing(100);


* 1) 처럼 호출부에서 타입 파라미터를 쓰지 않아도 컴파일러가 알아서 매칭해줌


멀티 파라미터를 사용한 제네릭 메소드 사용 예제는 다음 스크립트를 참조하자.

* CompareMethodExample.java, Util.java, Pair.java





타입 파라미터를 구체적으로 제한할 경우

public <T extends 상위타입> 리턴타입 메소드(매개변수, ...) {...}

단! 여기서 extends는 상속의 의미보다 '종류'로 받아들여야 한다.

해당 계통의 클래스로 사용을 제한한다는 뜻

interface객체도 참조할수 있으나 implements가 아닌 extends를 그대로 사용한다.



ex)
    public <T extends Number> int compare(T t1, T t2) {
        double v1 = t1.doubleValue();
        double v2 = t2.doubleValue();
        return Double.compare(v1, v2);
    }






와일드카드 타입

앞에서 다룬 제네릭 타입 메소드 사용시 타입 사용에 제한을 두는 것과 유사하나

앞에선 새로 선언할 타입 제한에 사용하였고

와일드 카드는 이미 선언된 제네릭 타입을 매개변수나 리턴타입으로 사용할 경우 제한하기 위해 다룬다.


사용예시

다음과 같이 A가 최상위로 두고

A <- B <- C <- D <- E 를 순서대로 상속하여 생성하였다 가정하자.

  제네릭타입 <?> : Unbounded Wildcards

  해당 타입 객체에 소속된 모든 클래스나 인터페이스 타입을 받을수 있다.



  제네릭타입<? extends 상위타입> : Upper Bounded Wildcards (상위 클래스 제한)

    제네릭타입<? extends C> 인경우 ? 자리에는 C와 C의 자식이 들어갈 수 있다.

    ex) C, D, E


  제네릭타입 <? super 하위타입> : Lower Bounded Wildcards (하위 클래스 제한)

    <? super C> 인경우 ? 자리에 C와 C의 부모가 들어갈 수 있다.

    ex) C, B, A


*** 자바 문법상 정해지지 않은 타입의 배열을 생성할 수 없으므로

Object 타입으로 미리 만들어 둔 다음 형 변환으로 바꾸어야 한다.

public Course(String name, int capacity) {
		this.name = name;
		students = (T[])(new Object[capacity]);
	}



설명보다 내용 참조가 더 중요하므로 Wildcards 패키지 참조 (WildCardExample.java 참조)




제네릭 인터페이스를 구현할 경우 들어서는 하위 클래스도 같은 계통의 제네릭타입이어야 한다.

제네릭 인터페이스 선언과 앞에서 다룬 제네릭 인터페이스 타입 참조는 다르다.


제네릭 인터페이스 선언 시

public class ChildProduct <K, V, C> extends Product<K,V> {...}

ChildProduct<Tv, String, String> product = new ChildProduct<>();

인터페이스에 선언한 제네릭 파라미터를 Implements 한 객체에서도 제네릭으로 선언해주어야 한다.

자세한 예시는 generic_extends_implements folder에서 ChildProduct.java 와 ChildProductAndStorageExample.java 참조








컬렉션 프레임워크

Collection 계열

  - List : 순서, 중복 가능 (ArrayListt, Vector, LinkedList)

  - Set : 순서 없음, 중복 불가 (HashSet, TreeSet)

Map 계열

  - 키와 값의 쌍으로 구성, 키는 중복 불가



List 컬렉션

배열처럼 인덱스로 관리 (추가, 찾기, 삭제)

* 삭제 시 자동으로 뒤의 객체를 앞으로 이동

    ex) List<String> list = ...;
        list.add("hyeon");        // 맨 끝에 객체 추가
        list.add(1, "kang");      // 1번 인덱스에 객체 삽입
        String str = list.get(1); // list의 1번 인덱스에 저장된 값을 str에 저장

        list.remove(0); // list의 0번 인덱스 항목 제거, (뒤의 인덱스 객체들이 한 칸씩 앞으로 이동)
        list.remove("hyeono"); // list의 "hyeon" 객체 삭제


* 전체 객체 루핑

for(String str : list) { // 매 루프마다 객체를 str에 저장
  printf(str);
}



물론 타입파라미터로 응용 가능

List<E> list = new ArrayList<E> (); // default 10칸 할당

List<String> list = ArrayList<String> (30); // 30칸 할당


* ArrayList는 기본적으로 10칸이 할당되나 저장용량이 초과할 경우 자동으로 확장



* ArrayList의 유효 객체 개수 구하기

10칸을 가진 ArrayList 를 선언했다고 가정하자.

list.add("java");
list.add("JDBC");
list.add("Servlet/JSP");

다음과 같이 3개의 객체를 추가하고

int size = list.size();
System.out.printlnn("총 개체수 : " + size);

print 문을 출력하면 list의 공간 수 10이 아닌 3이 출력된다.


만약 list.add(1, "aaa"); 를 추가했다면

ArrayList를 루핑 출력 했을 경우

0 : java
1 : aaa       // aaa를 1번 인덱스에 삽입하며 JDBC는 한 칸 뒤로 밀렸다.
2 : JDBC
3 : Servlet/JSP

처럼 출력 될 것이다.


삭제 역시 마찬가지로 인덱스 또는 객체 이름을 선언함으로 해당 객체를 제거할 수 있다.




Vector

Vector는 ArrayList와 용도가 같지만 Vector는 멀티스레드, ArrayList는 싱글스레드에서 사용함

스레드 동기화(syncronization)가 되어 있기 때문에

복수의 스레드가 동시에 접근해서 객체를 추가, 삭제하더라도 객체가 보호된다.

선언 방식도 같다.

List<E> list = new Vector<E> ();







LinkedList


연결리스트 객체 역시 ArrayList나 Vector처럼 선언하면 된다.

List<E> llist = new LinkedList<E> ();


연결리스트 특성을 그대로 계승

객체의 삭제와 삽입이 빈번한 경우 ArrayList보다 좋은 성능을 발휘함

단! 인덱스 참조 역시 불가능


List 컬렉션 완료





Set 컬렉션

Set은 집합과 같다. HashSet 등

중복저장이 불가능 하며 객체의 저장 순서가 따로 없음

따라서 순환하는데 다음과 같이 순환객체를 따로 부르거나 반복문으로 부름

ex)

    Set <String> set = new HashSet <String> ();

    set.add("Java");
    set.add("JDBC");

    Iterator <String> iterator = set.iterator();

    while(iterator.hasNext() ) {
        String element = iterator.next();
        System.out.println("\t" + element);
    }

    * hasNext(), next() 순환객체 메소드 말고 그냥 반복문도 가능

    for(String str : set) {
        System.out.println("\t" + str);
    }








Map 컬렉션

map 은 키와 값 쌍으로 구성

키는 중복 불가

ex)

    키와 값 추가
    V put(K key, V value);

    * 입력

    입력한 키 확인
    boolean containsKey(Object key);

    입력한 값 확인
    boolean containsValue(Object value);

    입력한 키 값 리턴
    V get(Object key);

    키와 값의 쌍으로 구성된 모든 Map.Entry 객체를 Set(집합) 에 담아서 리턴
    Set< Map.Entry<K,V> > entrySet();

    공백 확인
    isEmpty();

    모든 키를 Set 객체에 담아서 리턴 (왜 자꾸 Set으로만 반환하나)
    Set<K> ketSet();

    저장 객체 수 확인
    int size();

    저장된 모든 값을 Collection에 담아서 리턴
    Collection<V> values();

    전체 삭제
    void clear();

    특정 키 삭제
    V remove(Object key);




    객체 추가, 삭제

    ex)
        Map <String, Integer> map = ~; // <ket type, value type>
        map.put("홍길동", 30);         // 객체 추가
        int score = map.get("홍길동"); // 객체 찾기
        map.remove("홍길동");          // 객체 삭제


    전체 객체를 대상으로 반복해서 얻기

    * keySet(); 메소드 사용

    Map<K, V> map = ~;
    Set <K> keySet = map.keySet();
    Iterator <K> keyIterator = keySet.iterator();

    while(keyIterator.hasNext()) {
        K key = keyItterator.next(); // 결과 값으로 Key로 구성된 Set 리턴
        V value = map.get(key);      // 즉 Key만 따로 얻었기 때문에 value를 얻기 위해 추가작업
    }

    // 결과 값으로 Key로 구성된 Set 리턴
    // 즉 Key만 따로 얻었기 때문에 2차 가공


    * entrySet(); 메소드 사용

    Set <Map.Entry<K,V>> entrySet = map.entrySet();
    Iterator <Map.Entry<K, V>> entryIterator = entrySet.iterator();

    while (entryIterator.hasNext()) {
        Map.entry <K, V> entry = entryIterator.next();  // Map.entry 획득
        K key = entry.getKey();
        V value = entry.getValue();
    }

    // Map 형태로 얻어와서 바로 Key와 Value로 분할 가능




Map 인터페이스를 이용한 HashMap

ex)
    Map <K, V> map = new HashMap<K, V> ();

    Map<String, Integer> map = new HashMap<String, Integer>();

		//��ü ����
		map.put("신용권", 85);
		map.put("홍길동", 90); // 홍길동 1
		map.put("동장군", 80);
		map.put("홍길동", 95); // 홍길동 2(중복, 갱신)

		System.out.println("총 Entry 수: " + map.size()); // 사이즈 3 출력

		//��ü ã��
		System.out.println("홍길동 : " + map.get("홍길동")); // 홍길동 : 95 출력 (처음 입력한 90은 덮어씌워짐)
		System.out.println();













Stream






















IO 패키지 (Network Communicatoin)

java.io 패키지 : Input/Output API


바이트 기반 스트림 : 그림, 멀티미디어, 문자 등 모든 종류의 데이터를 다룸

InputStream, OutputStream

ex) FileInputStream, FileOutputStream


문자 기반 스트림 : 문자 송수신 특화

Reader, Writer

ex) FileReader, FileWriter




파일 입출력 예제

  public static void main(String[] args) throws Exception {
    InputStream is = new FileInputStream("C:/Temp/test.txt");
    int readByte;
    while ( (readByte = is.read()) != -1 ) {
      System.out.println(readByte); // 정수 출력
    }

    // * 또 다른 방법
    while(true) {
      readByte = is.read();
      if(readByte == -1) break;
      System.out.println( (char) readByte); // 아스키코드로 변환
    }
  }


입력 스트림과 출력 스트림과

read(byte[] b); 로 입력 스트림을 받을 경우

  InputStream is = new FileInputStream ( "C:/test.jpg");
  int readByteNo;
  byte[] readByte = new byte[3];

  while( (readByteNo = is.read(readBytes)) != -1) { // read메소드 인자로 배열을 주었으므로 배열에 들어간 데이터 인덱스 숫자를 반환
    System.out.println(readByteNo); // 배열에 들어간 입력 스트림 바이트 수 출력
    // 받을 데이터가 없으면 마찬가지로 -1 출력
  }


  // * 또 다른 방법
  while( true) {
    readByteNo = is.read(readByte);
    if (readByteNo == -1) break; // 입력 값이 없으면 -1 반환, 루프 탈출
    data += new String(readByte, 0, readByteNo);
  }

  System.out.println(data);


  추가 파라미터 입력

  read(byte[], int offset, int data_num);


   data stream은 close() 메소드로 닫아주어야 한다.




출력 스트림 :  OutputStream

  write() : 출력 스트림과

  flush() : 버퍼에 잔류하는 모든 바이트 출력

  close() : 시스템 자원 반납 & 출력 스트림 닫기


입출력 메모리에 1 byte 데이터가 들어있는 경우

write(int b) 메소드를 사용하면 int 단위 4byte가 통째로 출력되는 것이 아닌

데이터가 실제로 들어있는 1byte 만 출력된다.


ex) OutputStream

    public static void main(String[] args) throws Exception{
        OutputStream os = new FileOutputStream ("C:/Temp/test.txt");
        byte[] data = "ABC".getByte(); // byte배열에 문자열 "ABC"를 byte 단위로 쪼개서 저장

        for(int i=0; i<data.length; i++) {
          os.write(data[i]);
        }
        os.flush();

        os.close();
        // 출력스트림에서 write() 메소드를 사용하면
        // 출력 버퍼에 저장이 되었다 버퍼가 꽉 차면 출력이 된다.
        // 데이터가 충분히 들어오지 않아 버퍼에 갇혀있는 데이터를
        // flush() 메소드로 강제 출력과 동시에 버퍼 메모리를 초기화한다.

    }


파일 쓰기

  public class WriteExample {
    public sstatic void main(String []args ) throws Exception {
        OutputStream os = new FileOutputStream("C:/Temp/test.txt");
        byte[] data = "ABC".getByte();
        os.write(data);
        os.flush();
        os.close();
    }
  }






문자 기반 입력스트림 Reader class

int read(), (char[] cbuf), (char[] )

write 등 다른 메소드와 용법이 같다.


    Reader reader = new FileReader("파일 경로");
    int readData;
    while( true ) {
      readData = reader.read();
      if(readData == -1) break;
      System.out.print( (char) readData);
    }

    reader.close();



    * 다른 형태
    int readCharNo;
    char [] cbuf = new char[2];
    String data = "";
    while( (readCharNo = reader.read(cbuf)) != -1 ) {
      data += new String(cbuf, 0, readCharNo);
    }
    System.out.println(data);

    reader.close();



*** 프로토콜 사용시 일부 문자를 parsing해서 사용할 경우
read(char[] cbuf, int off, int len) 메소드






문자 기반 출력스트림 Writer class

write(), flush(), close()
