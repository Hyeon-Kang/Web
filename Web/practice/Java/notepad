문자열 비교는 논리연산자 ==이 아닌 equals("aaa")를 사용해야 함
ex) String str ="aaa";
    while(! str.equals("aaa") ){
    ......
    }

데이터 타입 분류

기본 (privitive type)
 - 정수 byte, int...
 - 실수 float, double
 - 논리 boolean

참조 (reference type)
 - array
 - enum
 - class
 - interface

 메모리 사용 영역

  - Heap : class와 array 생성, 실행중인 스레드 안의 JVM 스택에서 이곳을 참조하여
    필요한 데이터를 참조함

 new 를 사용하여 새로운 class 생성 (참조 대상이 같은지 다른지 유의!)

 다른 언어와 같이 parameter를 프로그램 혹은 함수 내부로 전달하려면 다음과 같이

 String args = {문자열0, 문자열1, 문자열2 ...};

 public static void main (String[] args) {
 ...
 }

 또는 다음과 같이 실행

 java 프로그램_이름 10 20

 근데 자바는 다른 프로그램과 달리 0, 1번 배열에 프로그램 저장 경로 등
 시스템 값이 안 들어가나?

 저장 데이터 제한하기 -> 열거형 (Enum)

 정적 초기화 블록

 ex class {
  static string a = "aa";
  static string b = "bb";
  static string c;
  static {
    c = a + "+" + b;
  }
 }


 singleton class
 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우

 이 경우 단 하나의 생성된 객체 이외의 다른 객체가 생성됨을 막기 위해
 class 외부에서 new 생성자를 호출할 수 없도록 막아야 함

 애플리케이션이 시작될 때 어떤 클래스가 최초 한번만 메모리를 할당하고(Static) 그 메모리에 인스턴스를 만들어 사용하는 디자인패턴.

생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나고 최초 생성 이후에 호출된 생성자는 최초에 생성한 객체를 반환한다.
(자바에선 생성자를 private로 선언해서 생성 불가하게 하고 getInstance()로 받아쓰기도 함)

싱글톤 패턴을 쓰는 이유

고정된 메모리 영역을 얻으면서 한번의 new로 인스턴스를 사용하기 때문에 메모리 낭비를 방지할 수 있음

또한 싱글톤으로 만들어진 클래스의 인스턴스는 전역 인스턴스이기 때문에 다른 클래스의 인스턴스들이 데이터를 공유하기 쉽다.

DBCP(DataBase Connection Pool)처럼 공통된 객체를 여러개 생성해서 사용해야하는 상황에서 많이 사용.

(쓰레드풀, 캐시, 대화상자, 사용자 설정, 레지스트리 설정, 로그 기록 객체등)

안드로이드 앱 같은 경우 각 액티비티나 클래스별로 주요 클래스들을 일일이 전달하기가 번거롭기 때문에 싱글톤 클래스를 만들어 어디서나 접근하도록 설계하는 것이 편하기 때문...




멀티쓰레드환경에서 동기화처리를 안하면 인스턴스가 두개가 생성된다든지 하는 경우가 발생할 수 있음

개발을 할때 항상 들어온 goto는 쓰면 안돼! 전역 객체는 안 좋은거야! 라는 말 처럼 꼭 필요한 경우아니면 지양해야함. // 적절히 잘 쓰면 아주 좋음, (그게 어렵지)


멀티 스레드 환경에서 싱글톤 클래스, 인스턴스 만드는 방법

출처: https://jeong-pro.tistory.com/86 [기본기를 쌓는 정아마추어 코딩블로그]




final field & constant

final 필드는 초기값이 저장되면 해당 필드 내용 불변

C 언어의 상수와 비슷하다. (static 까지 붙이면 같아진다.)

final 필드의 초기값 부여는 두 가지 경우밖에 없다.
1. 필드 선언 시 부여 (가장 편함. 그냥 class field 생성 시 기재하면 끝!)
2. 생성자에서 부여 (final init.java 에서 예제 확인)

final field는 비워두면 당연히 컴파일 에러 발생!

static final int = C언어 constant int




package

패키지는 단순히 파일시스템의 폴더 기능만이 아닌 클래스의 일부분이다.

패키지는 클래스의 유일성을 유지시켜줌

가량 클래스 이름이 같아도 패키지가 다르면 다른 클래스로 식별

class AA 의 위치가

상위패키지 - 하위패키지 - AA 처럼 되는 경우

호출 방식은 다음과 같다.

package 상위패키지.하위패키지

public class AA ....

전처리 과정 쓰듯 상단에 package 경로를 적어주면 된다.




접근 제한자

public > protected > default > private 순으로 접근 제한이 강화된다.

public : 뚫려있음

protected : 같은 패키지, 자식 클래스만 접근 가능
