문자열 비교는 논리연산자 ==이 아닌 equals("aaa")를 사용해야 함
ex) String str ="aaa";
    while(! str.equals("aaa") ){
    ......
    }

데이터 타입 분류

기본 (privitive type)
 - 정수 byte, int...
 - 실수 float, double
 - 논리 boolean

참조 (reference type)
 - array
 - enum
 - class
 - interface

 메모리 사용 영역

  - Heap : class와 array 생성, 실행중인 스레드 안의 JVM 스택에서 이곳을 참조하여
    필요한 데이터를 참조함

 new 를 사용하여 새로운 class 생성 (참조 대상이 같은지 다른지 유의!)

 다른 언어와 같이 parameter를 프로그램 혹은 함수 내부로 전달하려면 다음과 같이

 String args = {문자열0, 문자열1, 문자열2 ...};

 public static void main (String[] args) {
 ...
 }

 또는 다음과 같이 실행

 java 프로그램_이름 10 20

 근데 자바는 다른 프로그램과 달리 0, 1번 배열에 프로그램 저장 경로 등
 시스템 값이 안 들어가나?

 저장 데이터 제한하기 -> 열거형 (Enum)

 정적 초기화 블록

 ex class {
  static string a = "aa";
  static string b = "bb";
  static string c;
  static {
    c = a + "+" + b;
  }
 }


 singleton class
 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우

 이 경우 단 하나의 생성된 객체 이외의 다른 객체가 생성됨을 막기 위해
 class 외부에서 new 생성자를 호출할 수 없도록 막아야 함

 애플리케이션이 시작될 때 어떤 클래스가 최초 한번만 메모리를 할당하고(Static) 그 메모리에 인스턴스를 만들어 사용하는 디자인패턴.

생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나고 최초 생성 이후에 호출된 생성자는 최초에 생성한 객체를 반환한다.
(자바에선 생성자를 private로 선언해서 생성 불가하게 하고 getInstance()로 받아쓰기도 함)

싱글톤 패턴을 쓰는 이유

고정된 메모리 영역을 얻으면서 한번의 new로 인스턴스를 사용하기 때문에 메모리 낭비를 방지할 수 있음

또한 싱글톤으로 만들어진 클래스의 인스턴스는 전역 인스턴스이기 때문에 다른 클래스의 인스턴스들이 데이터를 공유하기 쉽다.

DBCP(DataBase Connection Pool)처럼 공통된 객체를 여러개 생성해서 사용해야하는 상황에서 많이 사용.

(쓰레드풀, 캐시, 대화상자, 사용자 설정, 레지스트리 설정, 로그 기록 객체등)

안드로이드 앱 같은 경우 각 액티비티나 클래스별로 주요 클래스들을 일일이 전달하기가 번거롭기 때문에 싱글톤 클래스를 만들어 어디서나 접근하도록 설계하는 것이 편하기 때문...




멀티쓰레드환경에서 동기화처리를 안하면 인스턴스가 두개가 생성된다든지 하는 경우가 발생할 수 있음

개발을 할때 항상 들어온 goto는 쓰면 안돼! 전역 객체는 안 좋은거야! 라는 말 처럼 꼭 필요한 경우아니면 지양해야함. // 적절히 잘 쓰면 아주 좋음, (그게 어렵지)


멀티 스레드 환경에서 싱글톤 클래스, 인스턴스 만드는 방법

출처: https://jeong-pro.tistory.com/86 [기본기를 쌓는 정아마추어 코딩블로그]



자바 클래스로더

: 자바 클래스를 JVM으로 동적 로드하는 JRE(자바 런타임 환경) 의 일부이다.

일반적으로 클래스는 요청 시 한 차례만 로드됨.

JRE는 클래스 로더 덕분에 파일과 파일 시스템에 대해 알 필요가 없다.
(하위 모듈 개념)

자바 클래스로더는 2가지 로드 방식이 있다.
1. 런타임 로딩 (요청 시 로드)
2. 로드 타임 로딩 (런타임 로딩에 의해 A클래스가 로딩될 때 내부에서 참조하는
   B, C 클래스도 같이 로딩)
   이 경우 원자적 특성으로 방해받지 않는 듯





final field & constant

final 필드는 초기값이 저장되면 해당 필드 내용 불변

C 언어의 상수와 비슷하다. (static 까지 붙이면 같아진다.)

final 필드의 초기값 부여는 두 가지 경우밖에 없다.
1. 필드 선언 시 부여 (가장 편함. 그냥 class field 생성 시 기재하면 끝!)
2. 생성자에서 부여 (final init.java 에서 예제 확인)

final field는 비워두면 당연히 컴파일 에러 발생!

static final int = C언어 constant int




package

패키지는 단순히 파일시스템의 폴더 기능만이 아닌 클래스의 일부분이다.

패키지는 클래스의 유일성을 유지시켜줌

가량 클래스 이름이 같아도 패키지가 다르면 다른 클래스로 식별

class AA 의 위치가

상위패키지 - 하위패키지 - AA 처럼 되는 경우

호출 방식은 다음과 같다.

package 상위패키지.하위패키지

public class AA ....

전처리 과정 쓰듯 상단에 package 경로를 적어주면 된다.




접근 제한자

public > protected > default > private 순으로 접근 제한이 강화된다.

public : 뚫려있음

protected : 같은 패키지 및 자식(하위) 클래스만 접근 가능

default : 같은 패키지에서 접근 허용

private : 현재 객체 내에서만 허용


그 밖의 Modifier

final
불변 객체를 의미한다.  final로 선언된 객체는 초기화 및 할당을 최초 1회만 수행할 수 있다.

static
인스턴스에 속한게 아닌, 클래스에 속해있는 변수로 여러 클래스가 공유하는 변수를 의미한다.
클래스가 인스턴스화 되기 전 클래스 로딩시점에 이미 생성되고
단 하나의 객체가 공유되는 개념으로 사용된다.

abstract
추상 메소드, 추상 인터페이스를 정의하는 키워드로 abstract method의 경우 하위 클래스에서
반드시 abstract 를 구현해야 한다.

synchronized
스레드 동기화를 위해서 사용되는 키워드로 synchronized로 선언된 메소드는
어떤 스레드가 대상 메소드를 실행중일때 다른 메소드가 접근을 못하도록 한다.
DB로 비유하면 TABLE LOCK의 개념과 유사하다.
메소드나 객체에 synchronized 키워드를 선언할 수 있다.

strictfp
자바에서 float이나 double형은 비트연산의 정밀도가 달라서 부동소수점 연산시
소수점 연산의 에러 가능성이 항상 존재한다.
strictfp 키워드를 클래스나 메소드에 지정하는 경우 부동수소점 숫자의 정밀도를 보장한다.

native (다른 언어 명시)
Interface를 설계 할 때 내부 메소드에 사용되는 키워드이다.
native는 자바가 아닌 다른언어(C나 C++)로 구현할 것이라도 알려주는 키워드이다.
JNI를 이용하여 이기종간 호환을 위해서 사용되는 키워드이다.

transient
Serialize의 반대개념
대상 변수는 직렬화/역직렬화 처리시 제외한다는 키워드이다.
키워드가 지정된 변수는 직렬화를 통한 오브젝트 통신시에 제외되고 처리된다.

volatile
멀티스레드 환경일 경우 각 스레드마다 동일 메모리를 공유하는 것이 아닌
별도 메모리 공간(CPU캐시)에서 변수를 읽어온다.
이런 경우 각 스레드마다 동일한 변수의 값을 다르게 기억할 수 있다.
volatile 키워드는 변수를 읽어 들일 때 CPU캐시가 아닌 컴퓨터의 메인 메모리로 부터
읽거나 쓰도록 처리한다.
volatile은 하나의 스레드에서만 쓰기작업을 하고,
다른 스레드는 읽기작업만 하는 경우 효율적으로 사용할 수 있다.
(synchronized 키워드는 여러 스레드에서 모두 읽기쓰기가 가능하다 = 공유자원)



Getter와 Setter 메소드

클래스 내부의 필드는 private로 직접 변조를 막고
따로 개입이 필요한 경우는 getter나 setter 메소드로
입력 값의 범위에 제한을 두거나 원하는 형태로 가공하여 return하는 것이 좋다.

ex) Getter & Setter

private int speed;

//Getter
public int getSpeed() {
  return speed;
}

//setter
public int setSpeed(int i) {
  this.speed = i;
}

만약 field 타입이 boolean 인 경우 Getter는 get이 아닌 is로 시작하는 것이 관례

boolean 앞에 is로 명명하였던 이유가 이거였구나.




Annotatoin 어노테이션

어노테이션은 일종으 메타데이터라 볼 수 있다.

어노테이션은 다음 과 같이 작성한다.

@AnnotationName

어노테이션의 용도
1. 컴파일러에게 코드 문법 에러를 체크하도록 정보를 제공
2. 소프트웨어 개발 툴이  빌드나 배치 시 코드를 자동으로 생성할 수 있도록 정보를 제공
3. 실행 시 (런타임 시) 특정 기능을 실행하도록 정보를 제공

영향을 미치는 주석같다?

대표적으로 @Override 어노테이션이 있다.

메소드 사용 시 @Override를 선언하면 컴파일러가 오버라이드 검사를 한다.

즉 실행 시 클래스 역할을 정의하기도 함



객체타입 확인 (instanceof)

슈퍼클래스와 서브클래스를 혼재해 사용하다 해당 객체가 부모인지 자식인지 혼동할 수 있다.
이 때

boolean result = 판별대상 객체 instanceof 비교 타입

좌항이 우항과 타입이 일치하면 true, 다르면 false를 반환한다.




추상클래스

인터페이스

둘 다 메소드 오버라이드 할 경우 @Override Annotation 가급적 붙여줄 것!


(p.351 인터페이스 구현 생략)




예외처리, 예외 클래스

에러(error) : 하드웨어의 오동작 또는 고장으로 발생한 실행 오류
예외(exception) : 사용자 및 코딩 오류...

예외는 두 가지 종류가 있다.
- 일반 예외 (exception) : 컴파일러 체크 예외
  (컴파일 과정에서 예외처리 코드가 필요한지 검사, 예외 처리가 없으면 컴파일 오류 발생)

- 실행 예외 (runtime exception) : 컴파일 과정에서 예외처리 코드를 검사하지 않는다.
  컴파일러가 검사하지 않기 때문에 오로지 개발자의 판단에 의해 예외처리 코드를 삽입해야 함.
  만약 실행 예외상황에 대한 대처 코드가 없을 경우 해당 상황 발생 시 프로그램은 바로 종료된다.


먼저 자주 발생하는 실행 예외의 경우

NullPointerException

null 값을 갖는 참조 변수를 참조 했을 때 출력되는 오류
객체가 없는데 객체를 요청하여 발생하는 사례이다.

ex) String data = null;
    System.out.println(data.toString());

    이렇게 null 상태인 data변수에 toString메소드를 요청하면

    NullPointerException 오류가 출력된다.



  ArrayIndexOutOfBoundsException

  배열에서 인덱스 범위를 초고하여 사용하는 경우 발생  (지정 범위 초과 오류)

  그러나 배열에 올바른 값이 들어있지 않은 경우에도 발생할 수 있다.

  ex) String data1 = arr[0];
      String data2 = arr[1];

      System.out.println("arr[0] : " + data1);
      System.out.println("arr[1] : " + data2);

      위 코드를 실행하면 ArrayIndexOutOfBoundsException 오류가 출력된다.

      이유는 arr에 적절한 매개변수가 들어가 있지 않기 때문


이와 같은 오류를 방지하기 위해

배열의 길이를 사전에 조사하거나 올바른 매개변수가 들어있는지 조사하는 코드를

삽입하는 것이 좋다.




NumberFormatException

문자열 데이터를 숫자로 변경하면서 숫자 값 이외의 문자열이 들어있으면

당연히 정상적으로 변환되지 않는다.

이 때 발생하는 오류가 NumberFormatException 이다.




ClassCastException

올바른 관계의 타입 변환(Casting)이 아니면 ClassCastException 오류가 출력된다.

상속관계 점검을 위해 instanceof 연산자를 사용할 것




try-catch-finally 블록을 통한 예외처리 코드 작성

try{
  예외 발생 가능 코드
} catch (예외처리 할 클래스 e) {
  예외 처리 코드
} finally {
  프로그램 지속 (안 쓰는 경우도 많음)
}


if문을 여러번 사용하듯이 catch문도 다중 선언 가능함


ex)

try {
  ArrayIndexOutOfBoundsException 발생

  NumberFormatException 발생
}

catch (ArrayIndexOutOfBoundsException e) {
  대응 코드
}

catch (NumberFormatException e) {
 대응 코드
}
