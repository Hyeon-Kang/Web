문자열 비교는 논리연산자 ==이 아닌 equals("aaa")를 사용해야 함
ex) String str ="aaa";
    while(! str.equals("aaa") ){
    ......
    }

데이터 타입 분류

기본 (privitive type)
 - 정수 byte, int...
 - 실수 float, double
 - 논리 boolean

참조 (reference type)
 - array
 - enum
 - class
 - interface

 메모리 사용 영역

  - Heap : class와 array 생성, 실행중인 스레드 안의 JVM 스택에서 이곳을 참조하여
    필요한 데이터를 참조함

 new 를 사용하여 새로운 class 생성 (참조 대상이 같은지 다른지 유의!)

 다른 언어와 같이 parameter를 프로그램 혹은 함수 내부로 전달하려면 다음과 같이

 String args = {문자열0, 문자열1, 문자열2 ...};

 public static void main (String[] args) {
 ...
 }

 또는 다음과 같이 실행

 java 프로그램_이름 10 20

 근데 자바는 다른 프로그램과 달리 0, 1번 배열에 프로그램 저장 경로 등
 시스템 값이 안 들어가나?

 저장 데이터 제한하기 -> 열거형 (Enum)

 정적 초기화 블록

 ex class {
  static string a = "aa";
  static string b = "bb";
  static string c;
  static {
    c = a + "+" + b;
  }
 }


 singleton class
 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우

 이 경우 단 하나의 생성된 객체 이외의 다른 객체가 생성됨을 막기 위해
 class 외부에서 new 생성자를 호출할 수 없도록 막아야 함

 애플리케이션이 시작될 때 어떤 클래스가 최초 한번만 메모리를 할당하고(Static) 그 메모리에 인스턴스를 만들어 사용하는 디자인패턴.

생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나고 최초 생성 이후에 호출된 생성자는 최초에 생성한 객체를 반환한다.
(자바에선 생성자를 private로 선언해서 생성 불가하게 하고 getInstance()로 받아쓰기도 함)

싱글톤 패턴을 쓰는 이유

고정된 메모리 영역을 얻으면서 한번의 new로 인스턴스를 사용하기 때문에 메모리 낭비를 방지할 수 있음

또한 싱글톤으로 만들어진 클래스의 인스턴스는 전역 인스턴스이기 때문에 다른 클래스의 인스턴스들이 데이터를 공유하기 쉽다.

DBCP(DataBase Connection Pool)처럼 공통된 객체를 여러개 생성해서 사용해야하는 상황에서 많이 사용.

(쓰레드풀, 캐시, 대화상자, 사용자 설정, 레지스트리 설정, 로그 기록 객체등)

안드로이드 앱 같은 경우 각 액티비티나 클래스별로 주요 클래스들을 일일이 전달하기가 번거롭기 때문에 싱글톤 클래스를 만들어 어디서나 접근하도록 설계하는 것이 편하기 때문...




멀티쓰레드환경에서 동기화처리를 안하면 인스턴스가 두개가 생성된다든지 하는 경우가 발생할 수 있음

개발을 할때 항상 들어온 goto는 쓰면 안돼! 전역 객체는 안 좋은거야! 라는 말 처럼 꼭 필요한 경우아니면 지양해야함. // 적절히 잘 쓰면 아주 좋음, (그게 어렵지)


멀티 스레드 환경에서 싱글톤 클래스, 인스턴스 만드는 방법

출처: https://jeong-pro.tistory.com/86 [기본기를 쌓는 정아마추어 코딩블로그]



자바 클래스로더

: 자바 클래스를 JVM으로 동적 로드하는 JRE(자바 런타임 환경) 의 일부이다.

일반적으로 클래스는 요청 시 한 차례만 로드됨.

JRE는 클래스 로더 덕분에 파일과 파일 시스템에 대해 알 필요가 없다.
(하위 모듈 개념)

자바 클래스로더는 2가지 로드 방식이 있다.
1. 런타임 로딩 (요청 시 로드)
2. 로드 타임 로딩 (런타임 로딩에 의해 A클래스가 로딩될 때 내부에서 참조하는
   B, C 클래스도 같이 로딩)
   이 경우 원자적 특성으로 방해받지 않는 듯





final field & constant

final 필드는 초기값이 저장되면 해당 필드 내용 불변

C 언어의 상수와 비슷하다. (static 까지 붙이면 같아진다.)

final 필드의 초기값 부여는 두 가지 경우밖에 없다.
1. 필드 선언 시 부여 (가장 편함. 그냥 class field 생성 시 기재하면 끝!)
2. 생성자에서 부여 (final init.java 에서 예제 확인)

final field는 비워두면 당연히 컴파일 에러 발생!

static final int = C언어 constant int




package

패키지는 단순히 파일시스템의 폴더 기능만이 아닌 클래스의 일부분이다.

패키지는 클래스의 유일성을 유지시켜줌

가량 클래스 이름이 같아도 패키지가 다르면 다른 클래스로 식별

class AA 의 위치가

상위패키지 - 하위패키지 - AA 처럼 되는 경우

호출 방식은 다음과 같다.

package 상위패키지.하위패키지

public class AA ....

전처리 과정 쓰듯 상단에 package 경로를 적어주면 된다.




접근 제한자

public > protected > default > private 순으로 접근 제한이 강화된다.

public : 뚫려있음

protected : 같은 패키지 및 자식(하위) 클래스만 접근 가능

default : 같은 패키지에서 접근 허용

private : 현재 객체 내에서만 허용


그 밖의 Modifier

final
불변 객체를 의미한다.  final로 선언된 객체는 초기화 및 할당을 최초 1회만 수행할 수 있다.

static
인스턴스에 속한게 아닌, 클래스에 속해있는 변수로 여러 클래스가 공유하는 변수를 의미한다.
클래스가 인스턴스화 되기 전 클래스 로딩시점에 이미 생성되고
단 하나의 객체가 공유되는 개념으로 사용된다.

abstract
추상 메소드, 추상 인터페이스를 정의하는 키워드로 abstract method의 경우 하위 클래스에서
반드시 abstract 를 구현해야 한다.

synchronized
스레드 동기화를 위해서 사용되는 키워드로 synchronized로 선언된 메소드는
어떤 스레드가 대상 메소드를 실행중일때 다른 메소드가 접근을 못하도록 한다.
DB로 비유하면 TABLE LOCK의 개념과 유사하다.
메소드나 객체에 synchronized 키워드를 선언할 수 있다.

strictfp
자바에서 float이나 double형은 비트연산의 정밀도가 달라서 부동소수점 연산시
소수점 연산의 에러 가능성이 항상 존재한다.
strictfp 키워드를 클래스나 메소드에 지정하는 경우 부동수소점 숫자의 정밀도를 보장한다.

native (다른 언어 명시)
Interface를 설계 할 때 내부 메소드에 사용되는 키워드이다.
native는 자바가 아닌 다른언어(C나 C++)로 구현할 것이라도 알려주는 키워드이다.
JNI를 이용하여 이기종간 호환을 위해서 사용되는 키워드이다.

transient
Serialize의 반대개념
대상 변수는 직렬화/역직렬화 처리시 제외한다는 키워드이다.
키워드가 지정된 변수는 직렬화를 통한 오브젝트 통신시에 제외되고 처리된다.

volatile
멀티스레드 환경일 경우 각 스레드마다 동일 메모리를 공유하는 것이 아닌
별도 메모리 공간(CPU캐시)에서 변수를 읽어온다.
이런 경우 각 스레드마다 동일한 변수의 값을 다르게 기억할 수 있다.
volatile 키워드는 변수를 읽어 들일 때 CPU캐시가 아닌 컴퓨터의 메인 메모리로 부터
읽거나 쓰도록 처리한다.
volatile은 하나의 스레드에서만 쓰기작업을 하고,
다른 스레드는 읽기작업만 하는 경우 효율적으로 사용할 수 있다.
(synchronized 키워드는 여러 스레드에서 모두 읽기쓰기가 가능하다 = 공유자원)




wrapper 클래스, Boxing / Unboxing

Integer age = new Integer(30);
// 30이 객체처럼 취급됨

Integer aa = 61;
// auto Boxing (new 생성자 없이도 자동으로 boxing처리)

Double avg = new  Double("3.145");

int a = age; // Auto Unboxing

일반적으로 wrapper 클래스 integer의 값을 불러오려면

age.intValue(); 를 사용해야 한다.

출처: https://hyeonstorage.tistory.com/168 [개발이 하고 싶어요]




Getter와 Setter 메소드

클래스 내부의 필드는 private로 직접 변조를 막고
따로 개입이 필요한 경우는 getter나 setter 메소드로
입력 값의 범위에 제한을 두거나 원하는 형태로 가공하여 return하는 것이 좋다.

ex) Getter & Setter

private int speed;

//Getter
public int getSpeed() {
  return speed;
}

//setter
public int setSpeed(int i) {
  this.speed = i;
}

만약 field 타입이 boolean 인 경우 Getter는 get이 아닌 is로 시작하는 것이 관례

boolean 앞에 is로 명명하였던 이유가 이거였구나.




Annotatoin 어노테이션

어노테이션은 일종으 메타데이터라 볼 수 있다.

어노테이션은 다음 과 같이 작성한다.

@AnnotationName

어노테이션의 용도
1. 컴파일러에게 코드 문법 에러를 체크하도록 정보를 제공
2. 소프트웨어 개발 툴이  빌드나 배치 시 코드를 자동으로 생성할 수 있도록 정보를 제공
3. 실행 시 (런타임 시) 특정 기능을 실행하도록 정보를 제공

영향을 미치는 주석같다?

대표적으로 @Override 어노테이션이 있다.

메소드 사용 시 @Override를 선언하면 컴파일러가 오버라이드 검사를 한다.

즉 실행 시 클래스 역할을 정의하기도 함



객체타입 확인 (instanceof)

슈퍼클래스와 서브클래스를 혼재해 사용하다 해당 객체가 부모인지 자식인지 혼동할 수 있다.
이 때

boolean result = 판별대상 객체 instanceof 비교 타입

좌항이 우항과 타입이 일치하면 true, 다르면 false를 반환한다.




추상클래스

인터페이스

둘 다 메소드 오버라이드 할 경우 @Override Annotation 가급적 붙여줄 것!


(p.351 인터페이스 구현 생략)




예외처리, 예외 클래스

에러(error) : 하드웨어의 오동작 또는 고장으로 발생한 실행 오류
예외(exception) : 사용자 및 코딩 오류...

예외는 두 가지 종류가 있다.
- 일반 예외 (exception) : 컴파일러 체크 예외
  (컴파일 과정에서 예외처리 코드가 필요한지 검사, 예외 처리가 없으면 컴파일 오류 발생)

- 실행 예외 (runtime exception) : 컴파일 과정에서 예외처리 코드를 검사하지 않는다.
  컴파일러가 검사하지 않기 때문에 오로지 개발자의 판단에 의해 예외처리 코드를 삽입해야 함.
  만약 실행 예외상황에 대한 대처 코드가 없을 경우 해당 상황 발생 시 프로그램은 바로 종료된다.


먼저 자주 발생하는 실행 예외의 경우

NullPointerException

null 값을 갖는 참조 변수를 참조 했을 때 출력되는 오류
객체가 없는데 객체를 요청하여 발생하는 사례이다.

ex) String data = null;
    System.out.println(data.toString());

    이렇게 null 상태인 data변수에 toString메소드를 요청하면

    NullPointerException 오류가 출력된다.



  ArrayIndexOutOfBoundsException

  배열에서 인덱스 범위를 초고하여 사용하는 경우 발생  (지정 범위 초과 오류)

  그러나 배열에 올바른 값이 들어있지 않은 경우에도 발생할 수 있다.

  ex) String data1 = arr[0];
      String data2 = arr[1];

      System.out.println("arr[0] : " + data1);
      System.out.println("arr[1] : " + data2);

      위 코드를 실행하면 ArrayIndexOutOfBoundsException 오류가 출력된다.

      이유는 arr에 적절한 매개변수가 들어가 있지 않기 때문


이와 같은 오류를 방지하기 위해

배열의 길이를 사전에 조사하거나 올바른 매개변수가 들어있는지 조사하는 코드를

삽입하는 것이 좋다.




NumberFormatException

문자열 데이터를 숫자로 변경하면서 숫자 값 이외의 문자열이 들어있으면

당연히 정상적으로 변환되지 않는다.

이 때 발생하는 오류가 NumberFormatException 이다.




ClassCastException

올바른 관계의 타입 변환(Casting)이 아니면 ClassCastException 오류가 출력된다.

상속관계 점검을 위해 instanceof 연산자를 사용할 것




try-catch-finally 블록을 통한 예외처리 코드 작성

try{
  예외 발생 가능 코드
} catch (예외처리 할 클래스 e) {
  예외 처리 코드
} finally {
  프로그램 지속 (안 쓰는 경우도 많음)
}


if문을 여러번 사용하듯이 catch문도 다중 선언 가능함

다중 catch문을 작성 시 주의점은 상위 예외 클래스가 하위 예외 클래스보다 아래에 위치해야 함

try 블록에서 예외 발생 시 catch 블록은 위에서부터 순서대로 검색하기 때문이다.

하위 -> 상위 (아래부터 위로)


ex)

try {
  ArrayIndexOutOfBoundsException 발생

  NumberFormatException 발생

  기타 exception 발생
}

catch (ArrayIndexOutOfBoundsException e) {
  대응 코드
}

catch (exception e) {
 대응 코드
}


이처럼 catch문을 여러개 사용할 수도 있지만

2가지 예외 상황에 같은 대응처리를 한다 가정을 해보자.

그렇다면 다음과 같이 작성하면 된다.

catch (ArrayIndexOutOfBoundsException | NumberFormatException e) {
  대응 코드
}

이처럼 예외 목록에 논리 연산자 사용이 가능함




resource 닫기

try-with-resources

예외 발생 여부와 상관없이(!) 사용했던 리소스 객체 (I/O stream, server socket, 등등 각종 채널 모두!)

close() 메소드를 호출하여 안전하게 닫아줌


사용하기 위해서는 java.lang.AutoCloseable 인터페이스를 implements해야 함

implements AutoCloseable

예제코드 close_resource_example.java 참조





예외 떠넘기기

throws

throws는 문제가 발생할 것으로 추정되는 메소드 뒤에 후술한다.

ex)

 public void method1() {

      try {

        method2();
      } catch (ClassNotFoundException e) {

        // 예외처리 코드
        System.out.println("클래스가 존재하지 않습니다.");
      }
 }

 public void method2() throws ClassNotFoundException {

    Class clazz = Class.forName("java.lang.Sting2");
 }


method1에서 호출되는 method2를 선언하면서 뒤에 throws를 후술한다.

이러한 경우 method2를 실행하며 발생한 예외가

method2를 호출한 method1의 try catch 문으로 처리를 한다.

이것이 왜 중요한가??

자바 프로그램을 개발하며 여러 API를 사용하는 과정에서 jdk에서 제공해주는 메소드의 경우

jdk document에서 method 소개 뒤에 throws 예외처리 구분이 있다면

그에 대한 대응을 만들어주어야 사용할 수 있다.


어떤 method의 throws 예외 구문이 있다면 try-catch를 후술하여

예외처리 코드를 작성해주어야 한다.

그러나 throws 뒤의 예외가 runtime exception이라면 try-catch를 사용하지 않아도 된다.


요약하자면 각종 api에서 참조한 에러를 내가 확인하고 대응하기 위해

jdk api 에서 불러온 method에서 발생한 예외를 내가 작성한 코드 안으로 예외를 떠넘겨야

사용자가 확인이 가능하다.





사용자 정의 예외 선언

사용자 정의 예외는 컴파일러가 체크하는 일반 예외로 선언 할 수도 있고

컴파일러가 체크하지 않는 실행 예외로 선언 할 수도 있다.

method처럼 사용자가 선언하며 생성자도 필요함.

ex)

public class exampleException extend Exception (실행 예외 RuntimeException 도 가능함) {
    public exampleException() {}  // 생성자 선언
    public exampleException(String message) { // 에러 스트링을 부모 클래스로 전달 (떠넘기기)
        super(message);
    }
}


호출 시 상위 클래스의 생성자를 호출하여 String 으로 된 예외 메시지를 넘겨준다.



인위적으로 예외를 발생시켜 처리 할 수도 있다.

throw new xxxException();

또는

throw new xxxException("메시지");

물론 사용 후 try-catch 블록으로 처리해주어야 함

userThrows.java 예시를 보자.



위에서 계속 다룬 try-catch-finally 블록을 보면

catch 에서 exception 뒤에 e를 붙인다.

이는 'e' 라는 예외 객체를 생성하는 것인데

e.getMessage(); 내장 메소드를 통해 예외 정보를 담은 메시지를 콘솔에 출력하거나

e.printStackTrace(); 메소드를 통해 해당 예외가 어느 지점에서 발생했는지

콘솔에 출력해주어 편하게 찾을 수 있다.

기타 예외처리 예제 참조





Java API

API = Library

자바 API를 찾아보기 쉽게 정리된 API document 링크를 첨부함

https://docs.oracle.com/en/java/javase/12/docs/api/index.html





객체 소멸자 .finalize()

참조하지 않는 배열이나 객체는 gc가 힙 영역에서 자동으로 소멸시킨다.

gc는 해당 객체를 소멸시키기 직전에 소멸자 finalize()를 실행시키는데

이때 마지막으로 사용한 자원 (연결, 파일 등)을 닫고 싶거나,

별도의 처리를 가하고 싶다면 다음과 같이 오버라이드하여 사용할 수 있다.

ex)

@Override
protected void finalize() throws Throwable {
  System.out.println(no + "번 객체의 finalize() 실행.");
}

또는 대상 객체를 null로 만들어 버린 다음에

System.gc(); // gc 호출

gc를 강제로 호출하여 소멸시키는 방법이 있다.




동적 객체 생성




멀티 스레드

멀티 프로세싱 vs 멀티 스레딩
: 전자는 여러 애플리케이션, 후자는 하나의 애플리케이션에서 여러 스레드 흐름 발생

멀티 스레드 애플리케이션을 개발하려면 먼저 몇 개의 작업을 병렬처리 할 것인지 정하고

각 작업별 스레드를 생성해야 한다.


작업 스레드 역시 자바에서 지원하는 thread 클래스를 객체화 하여 사용한다.

먼저 목표 함수(프로그램)을 실행할 매개로 갖는 thread를 생성한다.

Thread thread = new Thread(Runnable target);

// Runnable은 작업 스레드가 실행할 수 있는 코드를 가지고 있는 객체이다.

class Task implements Runnable {
  public void run() {
    //thread가 실행할 코드
  }
} // Task 객체 틀 생성

Runnable task = new Task();
// 생성한 Task 객체를 Runnable 타입 task로 선언

Thread thread = new Thread(task);
// 선언한 task를 thread 객체의 파라미터로 넣고 생성


요렇게 각 과정을 따로 작성해도 되지만 아래처럼 통합해도 된다.

Thread thread = new Thread( new Runnable() {
  public void run() {
    // thread가 실행할 코드
  }
});

thread 클래스 선언부 파라미터 구간에서 코드 작성해도 됨


물론 파라미터부에 람다식으로 작성해도 문제는 없다.

다만 람다식 특성상 디버깅이 어렵고 무명으로 선언되기에 재귀에 사용하기 까다롭기 때문에

가급적 사용을 자제하라는 글도 봄...


thread객체는 생성하면 바로 실행되는 것이 아니라 다음과 같이 실행 메소드를 사용해야 한다.

ex)

thread.start();

start() 메소드가 호출되면, 작업 스레드는 매개값을 ㅗ바든 Runnable의 run() 메소드를

실행한다.


beep 음과 콘솔창에 알림을 동시에 출력하는 프로그램을 예시로 들어보겠다.

먼저 메인 스레드만 이용한 경우이다.

    // 메인 스레드만 이용한 경우

    import java.awt.*; // beep 소리 출력 메소드에 사용

    public class BeepPrintExample1 {
      public static void main(Strint[] args) {
        Toolkit toolkit = Toolkit.getDefaultToolkit();
        // toolkit 객체 얻기 (비프음 메소드 호출에 필요)

        for(int i=0; i<5; i++)  {
          toolkit.beep();
          try {Thread.sleep(500);} catch(Exception e) {}

        } // for end : 0.5초의 딜레이를 가지고 beep음 출력

        for(int i =0; i<5; i++) {
          System.out.println("beep!");
          try {Thread.sleep(500);} catch(Exception e) {}
        } // for end : 0.5초의 딜레이를 가지고 beep 텍스트 콘솔창에 출력

      } // main end
    } // class end


    // 이렇게 메인 스레드에 작성을 하면 beep음만 0.5초 딜레이로 5번 출력 후
    // 콘솔창에 beep 텍스트가 0.5초 딜레이로 5번 출력 된다.

    // 즉 출력과 소리가 동시에 일어나지 않는다.



여기서 beep 음 출력 파트를 별도의 thread에 담아 실행해보자.

    // Beep 소리 출력 task 분리

    public class BeepTask implements Runnable {
      public void run() {
        Toolkit toolkit = Toolkit.getDefaultToolkit();
        for (int i =0; i<5; i++) {
          toolkit.beep();
          try{thread.sleep(500);} cathc(Exception e) {}
        }// for end
      } // run end
    } // class end


그리고 main thread를 다시 작성


    // BeepTask (소리 출력 Task 분리)

    public class BeepPrintExample2 {
      public static void main(String[] args) {
        Runnable beepTask = new BeepTask();
        Thread thread = new Thread(beepTask);

        for (int i=0; i<5; i++) {
          System.out.println("띵");
          try {Thread.sleep(500);} catch (Exception e) {}

        }
      }
    }


Thread의 이름 설정

생성한 스레드는 자동으로 Thread-n 형식의 이름을 갖는다.

main 스레드는 예외로 main이름의 thread를 갖게됨.

번호(n) 대신 스레드의 이름을 따로 짓고 싶다면 다음과 같이 setName 메소드를 사용




ex)
thread.setName("스레드 이름 정하기!");

반대로 스레드의 이름을 알고 싶다면

thread.getName();

두 메소드는 Thread의 인스턴스 메소드이므로 당연히 스레드 객체의 참조가 필요함

만약 현재 실행중인 스레드 객체의 참조 포인트가 없다면

정적메소드 currentThread() 로 현재 사용중인 스레드 이름을 얻을 수 있다.




ex) 현재 실행중인 스레드 읽어오기

Thread thread = Thread.currentThread();




여러 스레드를 동시에 운용하는 예제를 보자.

thread_name.java 참조

// 스레드의 구분을 위한 이름 설정 및 운용 예제

// 구성 요소 : ThreadNameExample.java, ThreadA.java, ThreadB.java


    public class ThreadNameExample {
      public static void main(String args[]) {
        Thread mainThread = Thread.currentThread();
        System.out.println("프로그램 시작 스레드 이름 : " + mainThread.getName());

        ThreadA threadA = new ThreadA();
        System.out.println("작업 스레드 이름 : " + threadA.getName());
        threadA.start();

        ThreadB threadB = new ThreadB();
        System.out.println("작업 스레드 이름 : " + threadB.getName());
        threadB.start();

      } // main end
    } // class end


그렇다면 스레드간의 우선순위는 어떻게 될까?


멀티 스레드는 동시성 (concurrency) 또는 병렬성 (parallelism)으로 실행됨

동시성 : 멀티작업을 위해 하나의 코어에서 멀티 스레드가 번갈아가며 실행되는 성질
(하나의 코어에서 여러 스레드를 굴린다.)

병렬성 : 멀티작업을 위해 멀티 코어에서 개별 스레드를 동시에 실행하는 성질
(여러 코어에서 여러 스레드를 굴린다)

스레드 스케줄링에 의해 스레드들은 짧은 시간에 번갈아가며 run() 메소드 안의

코드를 실행한다.



자바의 스레드 스케줄러는 우선순위 방식과 라운드 로빈 방식(순환 할당, time token)을 사용한다.

여기서 사용자가 개입할 수 있는 부분은 우선순위를 이용한 방식이다.

Thread 객체의 setPriority(1~10) 메소드를 통해 스레드의 우선순위를

수동으로 할당할 수 있다.

예시처 1~10 까지의 값을 부여할 수도 있으나

Thread 클래스 내부의 우선순위용 상수를 사용할 수도 있다.

*** 1의 우선순위가 가장 낮고 10의 우선순위가 가장 높게 부여된다.

ex)
thread.setPriority(Thread.MAX_PRIORITY);

Thread.MAX_PRIORITY : 10

Thread.NORM_PRIOIRTY : 5

Thread.MIN_PRIORITY : 1

운영체제 수업에서 배운 것 처럼 같은 우선순위의 작업은 그들간 라운드 로빈 방식을 취한다.


다음 우선순위를 설정한 스레드 예제를 참고해보자.

PriorityExample.java 참조

// 스레드 우선순위 부여 예제

// CalcThread.java 참조

    publicc class PriorityExample {
      public static void main(String args[]) {
        for (int i =0; i<=10; i++) {
          Thread thread = new  CalcThread("thread" + i);
          if (i !=10) {
            thread.setPriority(Thread.MIN_PRIORITY);
            // 가장 낮은 우선순위 설정
          } else {
            thread.setPriority(Thread.MAX_PRIORITY);
          } // if extend

          thread.start();
        }
      }
    }





공유객체를 통한 동기화 메소드, 동기화 블록

싱글 스레드 프로그램과 달리 멀티 스레드 프로그램은 여러 스레드가 객체의 자원을 공유하므로

자원 사용에 있어 각별히 신경써야 한다.

A, B 두 스레드가 하나의 필드를 공유한다고 가정해보자.

A가 해당 필드를 수정 도중에 B가 그 필드에 접근한다면

B는 A가 수정도중인 자료를 참조하게 되므로 사용할 수 없는 값이 나오게 된다.




공유 객체 예제


동기화 메소드 & 동기화 블록

C의 mutex 함수처럼 자바에도 스레드간 동시에 공유자원을 참조하지 못 하도록 잠금 기능이 있다.

자바는 critical section을 지정하기 위해 synchronized 메소드와 동기화 블록을 제공한다.

자바는 스레드가 동기화 메소드나 블록에 접근하면 객체에 잠금을 걸어 다른 스레드가

임계영역에 접근하지 못 하도록 제한한다.

동기화 객체에서 스레드가 작업을 마치고 실행 종료를 하면 잠금이 풀린다.




* 예를 들어 스레드1이 syncronized가 붙은 객체를 사용중일 때 스레드2는

syncronized가 붙은 다른 모든 메소드나 필드에 접근할 수 없다.

스레드 1의 syncronized 에서 실행중인 작업이 종료될 때 까지 일반 메소드만 접근 가능함




동기화 메소드는 메소드 선언부에 syncronized 키워드를 붙여 선언할 수 있다.

인스턴스와 정적 모두 선언 가능함.

ex) 임계영역 메소드 선언

public syncronized void method() {
  임계영역 코드;
}


ex) 일부만 임계영역으로 지정

public void method() {
  // 여러 스레드가 접근 가능한 영역

  syncronized(공유객체) {  // 대상이 자신이라면 this 사용 가능
    // 임계영역
  }

  // 여러 스레드가 접근 가능한 영역
}





스레드 상태 확인 메소드 getState()

getState() 메소드는 스레드 상태에 따라 몇 가지 열거 상수를 반환한다.

수동으로 할 경우

Thread.State state = 목표스레드.getState();

다음과 같이 담아서 사용 가능

* 스레드 상태 폴더 참조


스레드 상태 제어

yield() : 의미없는 작업 수행 시 다른 스레드에게 실행 순서 양도

stop() : 스레드 정지 수단이나 강제적이므로 stop보단 run을 빨리 끝낼 방안을 사용하자

join() : 다른 스레드의 종료를 기다림

두개의 스레드 A와 B가 있다 가정

 [threadA.java]
 threadB.start();
 threadB.join(); // thread A가 threadB의 결과를 받기 위해 연산이 끝날 때 까지 대기

 // 계산 결과 값을 받아 사용하는 경우에 다음과 같은 방식을 사용


wait(), notify(), notifyAll() 은 공유객체를 돌아가며 사용할 때

사용하는 메소드이므로 synchronized 메소드나 블록에서만 호출 가능하다.



위의 wait_notify를 이용하여 데이터를 생산하는 스레드와 소비하는 스레드의 예시를 보자

* Producer_Consumer_Example.java 참조



스레드의 안전한 종료 Stop플래그, interrupt();

stop 플래그가 아닌 stop() 메소드는 스레드를 즉시 졸료시키기 때문에 좀비 자원들이 남게 된다.





stop 플래그 예시

ex)

public class XXXThread extends Thread {
  private boolean stop; //stop 플래그 필드

  public void run() {
    while(!stop) {            // stop이 true가 되면 루프문 탈출 -> run() 메소드 종료
      // 스레드가 반복 실행하는 코드;
    }

    // 스레드가 사용한 자원 정리
  }
}

* StopFlagExample.java 참조

stopflag 는 현재 다루고 있는 스레드를 종료시킬 수 있으나

일시정지 상태인 스레드는 정지시킬 수 없다.


이처럼 일시정지 상태인 스레드를 종료할 때 interrupt 메소드를 사용한다.

interrupt 메소드는 runnable(실행대기)이거나 execution(실행)상태의 스레드에 사용할 수 없다..





Interrupt()를 사용한 스레드 상태제어

A스레드에서 B스레드로 Interrupt Exception을 유도하기 위해선 B스레드가 일시정지 상태가

되어야 한다.


interrupt 메소드가 일시정지가 아닌 상태에서 호출되면 그 다음 일시정지가 될 경우에

자동으로 호출된다.


스레드 실행 중 인터럽트 개입이 필요한 경우 thread.interrupt(); 메소드나 isInterrupt();

메소드를 참조하여 불 대수 값을 얻어내 플래그를 세우도록 하자.



데몬 스레드를 응용한 자동 저장 기능을 갖춘 스레드의 간단한 예시를 보자

* DaemonExample.java 참조






스레드 그룹

관련된 스레드를 묶어서 운용

계층적으로 하위 스레드 그룹을 가질 수 있음

System 그룹에서 JVM 운용에 필요한 스레드와 메인 스레드를 자동으로 생성한다.


스레드는 반드시 스레드 그룹에 속해있어야 하며

자신을 생성한 스레드와 같은 그룹에 소속됨


스레드 그룹 이름 얻기

ex)

ThreadGroup group = Thread.currentThread.getThreadGroup();

또는

String GroupName = group.getName();




JVM이 생성한 스레드를 살펴보고 주 스레드와 데몬스레드 관찰

* groupExample.java 에서 다음과 같은 결과를 얻었다.


for(Thread thread : threads) {
			System.out.println("Name : " + thread.getName() + ((thread.isDaemon()?"(데몬)":"(주)")));
		}


    Name : Signal Dispatcher(데몬)
    Name : Common-Cleaner(데몬)
    Name : Reference Handler(데몬)
    Name : main(주)
    Name : Attach Listener(데몬)
    Name : Finalizer(데몬)
    Name : AutoSaveThread(데몬)


이제 스레드의 역할은 파악하였다. 소속 그룹을 확인해보자



for(Thread thread : threads) {
			System.out.println("Name : " + thread.getName() + ((thread.isDaemon()?"(데몬)":"(주)")));
			System.out.println("\t" + "소속그룹 : " + thread.getThreadGroup().getName());
			System.out.println();
		}


  Name : Signal Dispatcher(데몬)
	  소속그룹 : system

  Name : Common-Cleaner(데몬)
  	소속그룹 : InnocuousThreadGroup

  Name : Reference Handler(데몬)
  	소속그룹 : system

  Name : main(주)
  	소속그룹 : main

  Name : Attach Listener(데몬)
  	소속그룹 : system

  Name : Finalizer(데몬)
  	소속그룹 : system

  Name : AutoSaveThread(데몬)
  	소속그룹 : main





스레드 그룹 선언

스레드를 선언 할 때 2가지 방법이 있었다.

ex)

1.

Thread t = new Thread (new Runnable() {

  @Override
  public void run() {
    // 실행 코드
  } // run end

} ) // Thread t end



2.

class t extends Thread {

  public void run() {
    // 실행 코드
  } // run end
} // t end


여기서 전자의 경우

Thread t = new Thread(ThreadGroup group, Runnable target);
// 초기 파라미터로 지정



후자의 경우

class t extends Thread {

  public t (ThreadGroup group, String threadName) {
    super(group, threadName); // 상속 형식으로 지정
  }

  public void run() {}
}




스레드 그룹 통제

그룹 단위로 스레드 통제 메소드 참조

activeCount()
activeGroupCount()
checkAccess()
destory()
getMaxPriority()
setMaxPriority(int pri)
.
.
.
inturrept()



스레드 그룹에 interrupt() 명령을 호출하면

그룹 내 모든 하위 스레드에 interrupt() 명령이 전달된다.







스레드 풀 (Excutor Service)


자원의 한계로 스케쥴을 짜서 스레드를 운용할 필요가 있다.

따라서 작업 큐와 스레드 풀을 사용함


자바는 ExecutorService 인터페이스와 Executor 클래스를 통해

스레드 풀 관련 패키지를 재공한다.

java.util.concurrent 패키지에서 제공.


Thread pool = ExecutorService 객체

ExecutorService 내부에는 작업 큐와 스레드가 존재한다.

서버 애플리케이션에서 필수로 사용하므로 향후 네트워크 파트를 대비햐여 잘 숙지할 것!



초기 스레드 수 : 스레드 풀을 초기 생성 시 기본적으로 들어가있는 스레드 수

코어 스레드 수 : 스레드 풀에 스레드가 전개되었을 때 사용되지 않는 스레드를 제거하며

                제거하지 않고 최소로 유지하는 스레드 수

최대 스레드 수 : ...



newCachedThreadPool()

초기 스레드 수 : 0, 코어 스레드 수 : 0, 최대 스레드 수 : Integer의 최대 값 만큼

이론적으로 Int값의 한계만큼 가능하나 운영체제가 가진 메모리 상황에 따라 달라짐

추가된 스레드가 60초 이상 아무런 작업도 하지 않으면 해당 스레드를 종료하고 풀에서 제거함


ex) ExecutorService threadpool = Executors.newCachedThreadPool(); // 스레드 풀 객체는 정적메소드



newFixedThreadPool(int n Threads) // 매개 변수로 최대 스레드 개수 int 값 부여

CachedThreadPool 과는 달리 유휴상태 스레드가 제거되지 않는다.

코어 스레드 개수 : n, 최대 스레드 수 : n

ex) 매개변수로 cpu가 가지고 있는 코어의 수를 전달

ExecutorService threadPool = Executors.newFixedThreadPool(
  Runtime.getRuntime().availableProcessors() // cpu의 코어 수 획득
); // threadPool end



ex) 세부사항 부여 : 코어 스레드 3, 최대 스레드 100개인 스레드풀 생성

ExecutorService threadPool = new ThreadPoolExecutor(

3,    // 코어 스레드 개수
100,  // 최대 스레드 개수
120L, // 놀고 있는 시간 제한
TimeUnit.SECONDS, // 놀고있는 시간 단위  (120L, SECONDS : 120초)
new SynchronuosQuewe<Runnable>() // 작업큐
)



스레드 풀 종료

* 스레드 풀의 스레드는 기본적으로 데몬 스레드가 아님

따라서 main 스레드가 종료되더라도 스레드풀의 스레드는 작업을 계속 처리한다.

따라서 애플리케이션을 종료하기 위해서는 스레드풀의 모든 스레드를 종료시켜야 한다.


스레드 풀 종료 메소드에

shutdown() : 작업큐와 현재 작업중인 모든 스레드의 작업을 마친 뒤 종료

shutdownNow() : 현재 처리중인 스레드에 interrupt()를 걸어 작업 중지를 시도하고

                스레드 풀을 종료함. 큐에 남은 미처리 작업목록을 반환함

awaitTermination(long timeout, TimeUnit unit) : 시간과 단위를 매개변수로 준다.

이렇게 지정된 시간 내에 끝난 작업은 True로 처리하고 시간 내 끝내지 못한 작업은

인터럽트를 걸어 중지시키고 False를 반환한다.



가급적이면 작업을 안전하게 종료시킨 뒤에 애플리케이션을 닫는 shutdown()을 사용해야 함





작업 생성

작업은 Runnable과 Callable 클래스 두 가지가 있다.

Runnable 객체는 리턴 값이 없고 Callable 객체는 리턴값이 있는 것이 대표적인 차이

위에서 많이 다루었듯이

Runnable 클래스는 다음과 같다.

    Runnable task  = new Runnable() {

      @Override
      public void run() {
        // 스레드가 처리할 작업 내용
      }
    }

run 메소드 내부의 코드만 실행하고 끝난다.

즉, 작업이 끝나며 별 다른 리턴 값이 발생하지 않는다.


Callable 클래스는 제네릭 타입으로 결과 값 타입을 지정해주어야 한다.

* 리턴 자료형 String 예시

Callable<T> task = new Callable<T> {
  @Override
  public T call() throws Exception {
    //스레드가 처리할 작업 내용
    return T;
  }
}





작업 처리 요청

ExcecutorService의 작업 큐에 Runnable 또는 Callble 객체를 넣는 행위


execute(Runnable command) : 작업 큐에 넣을 Runnable 객체를 매개변수로 받는다.

작업 처리 결과를 받지 못 하는 것이 특징.
(결과 값이 없는 작업을 큐에 넣을 때 사용)


submit(Runnable task) : 작업 결과를 얻을 때 사용, Future<V> 지정 타입으로 결과 반환



작업 처리 도중에 예외가 발생한 경우

execute(); 메소드의 경우 스레드가 종료되며 해당 스레드는 제거된다.

따라서 스레드풀은 다른 작업 처리를 위해 새로운 스레드를 생성함.


submit(); 메소드의 경우 예외가 발생한 스레드가 종료되지 않고 다음 작업을 위해 재사용.



스레드 생성에 소모되는 자원 때문에 가급적 submit() 메소드를 사용하는 것이

오버헤드를 줄이는데 도움이 된다.




블로킹 방식의 스레드 풀

스레드 풀 예제 Execute_VS_Callable_Example.java 에서

작업 결과를 반환하지 않는 실행 객체 예시를 보았다.

Execute 메소드와 달리 submit 메소드는 연속으로 실행할 때 예외 오류가 출력되지 않았는데

이러한 경우 해당 작업이 정상적으로 종료되었는지 확인하기 위해 Future 객체가 필요하다.


다음 예시를 참조하여 리턴 값이 없는 스레드의 실행 결과 통보 방법을 보자


* NoResultExample.java
