모던 자바스크립트(javascript) 개발을 위한 ES6 강좌 (강의 등록년도 2017)

ESMAScript6

ES6 === ES2015

ES6?? :
가장 개선된 JavaScript 문법
불필요 요소 최소화
ES6를 기반으로 한 JS 생태계 확산

ES6의 브라우저 지원율을 보고 싶다면 ES6 compatibillity 검색

17년도 기준 IE 11과 일부 안드로이드에서 지원률이 떨어지는 경향이 보이나
Babel을 사용하면 ES6 코드를 ES5로 쉽게 바꿀 수 있다고 한다.

즉, ES6로 스크립트를 작성한 뒤 Babel을 사용하여 ES5로 변환, 웹 서비스로 배포하면 국내 모바일 환경에서도 정상적으로 지원 될 것이다.



Babel? Webpack?


** 코드 실행은 http://jsbin.com/ 에서 함



01. scope

    let?

    지금까지 JS의 변수 선언 방법은 var 키워드가 유일했으며, 다음과 같은 특성을 가지고 있다.
    1. 함수 레벨 스코프 (지역변수 개념)
    2. var 키워드 생략 가능 (암묵적 전역변수 양산 가능성 문제)
    3. 변수 중복선언 허용 (잘못된 값의 덮어쓰기 및 참조 문제)
    4. 변수 호이스팅(Hoisting)??  ** hoist : 감아 올리다, 끌어 올리다
    : 자바스크립트 함수는 실행되기 전 함수 내부의 로컬변수들을 모두 모아 가능한 최상단에 선언 후  동작한다. 즉, 변수가 선언되기 이전에 참조되는 문제가 발생할 수 있다.
    (실제로 값이 들어가진 않았지만 hoisting으로 선언되어 인식되는 문제)

    ES6의 let은 이러한 var 키워드의 단점을 보완하기 위해 let과 const 키워드를 도입함



    ** 자바스크립트는 통상 언어들이 블록레벨 스코프를 지원하는 것과 달리 함수레벨 스코프를 지원한다.

    무슨 말이냐 하면 아래의 예제 코드를 보자.

    var foo = 123; // 전역 변수
    console.log(foo); // 123
    {
    var foo = 456; // 전역 변수
    }
    console.log(foo); // 456

    다른 언어에서는 블록 내외의 foo가 서로 독립적인 변수이며 블록 내의 foo는 외부에서 참조 할 수 없다.

    그러나 자바스크립트의 경우 함수레벨 스코프를 지원하기 때문에 foo는 전역변수 옵션으로 2번 선언된 것과 같은 형태이다.


    다시 돌아와서 let의 특징을 보자.

    ** let 키워드의 기능
    1. 블록 레벨 스코프 변수 선언
    2. 변수 중복 선언 금지
    3. 호이스팅 방식 변환
    : var 키워드 변수와 달리 let 변수는 코드상 선언 위치 이전에 참조하면 에러가 뜨도록 바뀌었다.
    사용자가 변수 선언 위치를 조금 더 신경써야 하겠지만 var처럼 암묵적 호이스팅으로 Temporal Dead Zone; TDZ 사각지대에 빠지는 것을 방지할 수 있다.


02. const

    document.querySelector() : querySelector 는 특정 name 이나 id 를 제한하지않고 css선택자를 사용하여 요소를 찾습니다.

    querySelectorAll 은 querySelect 과 동일하게 작동하나 차이점은 해당 선택자에 해당하는 모든 요소를 가져옵니다.

    반환객체는 nodeList이기때문에 for문 또는 foreach 문을 사용해야 합니다.

    또한 (',') 을 사용하면  여러요소를 한번에 가져올수있습니다.

    js 사용 예시
    var sections = document.querySelectorAll("#sections , #sections .section");
    console.log(sections.constructor.name)
    for( var i = 0; i < sections.length; i++ ){
    var item = sections.item(i);
    item.style.border = "1px solid #ff0000";
    }


    참조링크 : https://javacpro.tistory.com/36



    let과 closure

    다음 예제는 html로 생성된 리스트를 클릭하면 몇 번째 리스트인지 콘솔창에 출력해주는 프로그램이다.


    html

    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width">
      <title>JS Bin</title>
    </head>
    <body>
     <ul>
      <li>javascript</li>
      <li>java</li>
      <li>python</li>
      <li>django</li>
      </ul>
    </body>
    </html>


    js

    var list = document.querySelectorAll("li");
    for(var i=0; i<list.length; i++) {
      list[i].addEventListener("click", function(){
        console.log(i + "번째 리스트 입니다.");
      })
    }

    그런데 결과는 4번째만 뜬다?

    이는 callback 함수 function 나중에 실행되며 i 값 참조 문제가 발생한 것이다.
    function이 참조하는 i 값이 올바르게 참조되지 않아 발생하는 문제

    여기서 i는 closure 변수라 할 수 있다.

    즉 i는 전역변수화 되어 마지막 결과인 4가 모두에게 공유되는 상황

    i를 지역변수화 시켜야 한다.


    js 코드에서 for문 안의 var i를 let i로 변경해보자.

    i가 전역변수에서 지역변수로 변해 정상적으로 프로그램이 동작함을 알 수 있다.

    var list = document.querySelectorAll("li");
    for(let i=0; i<list.length; i++) {
      list[i].addEventListener("click", function(){
        console.log(i + "번째 리스트 입니다.");
      })
    }



    const 키워드는 다른언어와 용법이 비슷하다.
    상수화 시켜서 중요한 파라미터 보호

    사실 const는 불변은 아니고 그저 재 할당을 막는 것

    다음 js 예제를 보자

    function home() {
        const list = ["aa", "bb", "cc"];
        list.push("dd");                    //c언어의 경우 불가능
        console.log(list);
    }

    C언어와 다르게 콘솔 출력 결과를 보면 "dd"가 list에 추가되어있는것을
    확인할 수 있다.

    const를 사용하더라도 배열과 오브젝트의 값을 변경하는 것은 가능하다.

    ** 추가는 가능하지만 재할당은 불가능

    그럼 불변의 배열은 어떻게 만들까?



    ES6에서 제공하는 String 메소드

    let str = "hello world ! ^^ ~~";

    str이 hello로 시작하는 문자열임을 확인하려면 어떻게 할까?

    비교용 문자열 matchstr 선언

    let matchstr = "hello";

    consloe.log( str.startWich(matchstr) ); // str이 matchstr로 시작하는지 검사
     -> true 반환

    끝이 "~~" 인지 확인하는 법
    let matchstr1 = "~~";
    console.log(str.endWith(matchstr1));
     -> true 반환

    특정 문자열이 포함하는지 검사하는 메소드는 includes() 가 있다.

    앞, 뒤, 포함 여부 검사 (startWich, endWitch, includes)




    array 순회하기

    var data = [1, 2, undefined, NaN, null, ""];
    for(let i =0; i<data.length; i++) {
        console.log(value);
    }

    data.forEach(function(value) {
        console.log(value);
    });

    for(let value of data) {
        consloe.log(value);
    }



    spread operator를 응용한 배열 복사

    // spread operator : 펼침연산자(...)

    let pre = ["apple", "orange", 100];
    let newData = [...pre];  // ...pre는 pre를 펼쳐놓은 것과 같은 의미
    console.log(pre,newData);

    배열 pre가 newData로 복사됨
    하지만 참조값은 달라서
    console.log(pre === newData);
     -> false 반환 (메모리의 새로운 공간에 복제함)


    spread operator를 응용하여 두 배열을 합쳐보자

    let arr1 = [100,200,"hello",null];
    let newData = [0,1,2,3, ...pre, 3];

    배열의 인자를 매개변수로 바로 사용할때 편리함

    자바스크립트 입력 인자 변수로 가져오는 법

    ex)
    function addMark() {
        let newData = [];

        for(let i=0; i<arguments.length; i++) {
            newData.push(arguments[i] + "!");
        }

        console.log(newData);
    }

    addMark(1,2,3,4,5); // addMark 함수에 1,2,3,4,5 인자 전달!

    arguments는 로컬변수 판정을 받으며, 함수 실행시 인자로 받은 데이터를 배열로 받아온다.

    받은 데이터에 '!' 를 붙여 저장


    arguments.length는 가변적 길이를 갖는 데이터를 다룰 때 많이 사용


    함수의 인자로 가져온 데이터들을 배열로 만들기

    function addMark() {
        let nerArray = Array.from(arguments); // 받은 인자들을 배열로 만든다.
        let newData = newArray.map(function(value) { // 만든 배열을 가공하여 newData에 결과 저장
            return value + "!";
        });

        console.log(newData);
    }

    addMark(1,2,3,4,5,6,7,8,9);




    실습예제1 : html 문서 list에서 e 가 들어가는 객체 개수 찾기















    클로저???

    클로저는 외부함수를의 변수에 접근할 수 있는 내부함수를 말한다.
    뭔 소리여






    자바스크립트 메소드 정리
    document.getElementById(클래스 id) : 클래스 id를 지닌 요소의 값을 가져옴
    innerHTML : getElementById로 가져온 값을 변경할 때 사용

    ex)
    var count = document.getElementById('count');
    count.innerHTML = increase();


    ES6 메소드 정리
    let
    const
    startWich(string)
