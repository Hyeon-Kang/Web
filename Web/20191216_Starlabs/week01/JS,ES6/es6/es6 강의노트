모던 자바스크립트(javascript) 개발을 위한 ES6 강좌 (강의 등록년도 2017)

ESMAScript6

ES6 === ES2015

ES6?? :
가장 개선된 JavaScript 문법
불필요 요소 최소화
ES6를 기반으로 한 JS 생태계 확산

ES6의 브라우저 지원율을 보고 싶다면 ES6 compatibillity 검색

17년도 기준 IE 11과 일부 안드로이드에서 지원률이 떨어지는 경향이 보이나
Babel을 사용하면 ES6 코드를 ES5로 쉽게 바꿀 수 있다고 한다.

즉, ES6로 스크립트를 작성한 뒤 Babel을 사용하여 ES5로 변환, 웹 서비스로 배포하면 국내 모바일 환경에서도 정상적으로 지원 될 것이다.



Babel? Webpack?


** 코드 실행은 http://jsbin.com/ 에서 함



01. scope

    let?

    지금까지 JS의 변수 선언 방법은 var 키워드가 유일했으며, 다음과 같은 특성을 가지고 있다.
    1. 함수 레벨 스코프 (지역변수 개념)
    2. var 키워드 생략 가능 (암묵적 전역변수 양산 가능성 문제)
    3. 변수 중복선언 허용 (잘못된 값의 덮어쓰기 및 참조 문제)
    4. 변수 호이스팅(Hoisting)??  ** hoist : 감아 올리다, 끌어 올리다
    : 자바스크립트 함수는 실행되기 전 함수 내부의 로컬변수들을 모두 모아 가능한 최상단에 선언 후  동작한다. 즉, 변수가 선언되기 이전에 참조되는 문제가 발생할 수 있다.
    (실제로 값이 들어가진 않았지만 hoisting으로 선언되어 인식되는 문제)

    ES6의 let은 이러한 var 키워드의 단점을 보완하기 위해 let과 const 키워드를 도입함



    ** 자바스크립트는 통상 언어들이 블록레벨 스코프를 지원하는 것과 달리 함수레벨 스코프를 지원한다.

    무슨 말이냐 하면 아래의 예제 코드를 보자.

    var foo = 123; // 전역 변수
    console.log(foo); // 123
    {
    var foo = 456; // 전역 변수
    }
    console.log(foo); // 456

    다른 언어에서는 블록 내외의 foo가 서로 독립적인 변수이며 블록 내의 foo는 외부에서 참조 할 수 없다.

    그러나 자바스크립트의 경우 함수레벨 스코프를 지원하기 때문에 foo는 전역변수 옵션으로 2번 선언된 것과 같은 형태이다.


    다시 돌아와서 let의 특징을 보자.

    ** let 키워드의 기능
    1. 블록 레벨 스코프 변수 선언
    2. 변수 중복 선언 금지
    3. 호이스팅 방식 변환
    : var 키워드 변수와 달리 let 변수는 코드상 선언 위치 이전에 참조하면 에러가 뜨도록 바뀌었다.
    사용자가 변수 선언 위치를 조금 더 신경써야 하겠지만 var처럼 암묵적 호이스팅으로 Temporal Dead Zone; TDZ 사각지대에 빠지는 것을 방지할 수 있다.


02. const

    document.querySelector() : querySelector 는 특정 name 이나 id 를 제한하지않고 css선택자를 사용하여 요소를 찾습니다.

    querySelectorAll 은 querySelect 과 동일하게 작동하나 차이점은 해당 선택자에 해당하는 모든 요소를 가져옵니다.

    반환객체는 nodeList이기때문에 for문 또는 foreach 문을 사용해야 합니다.

    또한 (',') 을 사용하면  여러요소를 한번에 가져올수있습니다.

    js 사용 예시
    var sections = document.querySelectorAll("#sections , #sections .section");
    console.log(sections.constructor.name)
    for( var i = 0; i < sections.length; i++ ){
    var item = sections.item(i);
    item.style.border = "1px solid #ff0000";
    }


    참조링크 : https://javacpro.tistory.com/36



    let과 closure

    다음 예제는 html로 생성된 리스트를 클릭하면 몇 번째 리스트인지 콘솔창에 출력해주는 프로그램이다.


    html

    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width">
      <title>JS Bin</title>
    </head>
    <body>
     <ul>
      <li>javascript</li>
      <li>java</li>
      <li>python</li>
      <li>django</li>
      </ul>
    </body>
    </html>


    js

    var list = document.querySelectorAll("li");
    for(var i=0; i<list.length; i++) {
      list[i].addEventListener("click", function(){
        console.log(i + "번째 리스트 입니다.");
      })
    }

    그런데 결과는 4번째만 뜬다?

    이는 callback 함수 function 나중에 실행되며 i 값 참조 문제가 발생한 것이다.
    function이 참조하는 i 값이 올바르게 참조되지 않아 발생하는 문제

    여기서 i는 closure 변수라 할 수 있다.

    즉 i는 전역변수화 되어 마지막 결과인 4가 모두에게 공유되는 상황

    i를 지역변수화 시켜야 한다.


    js 코드에서 for문 안의 var i를 let i로 변경해보자.

    i가 전역변수에서 지역변수로 변해 정상적으로 프로그램이 동작함을 알 수 있다.

    var list = document.querySelectorAll("li");
    for(let i=0; i<list.length; i++) {
      list[i].addEventListener("click", function(){
        console.log(i + "번째 리스트 입니다.");
      })
    }



    const 키워드는 다른언어와 용법이 동일하다.
    상수화 시켜서 중요한 파라미터 보호

    사실 const는 불변은 아니고 그저 재 할당을 막는 것

    다음 js 예제를 보자

    function home() {
        const list = ["aa", "bb", "cc"];
        list.push("dd");                    //c언어의 경우 불가능
        console.log(list);
    }

    C언어와 다르게 콘솔 출력 결과를 보면 "dd"가 list에 추가되어있는것을
    확인할 수 있다.





    자바스크립트 메소드 정리
    document.getElementById(클래스 id) : 클래스 id를 지닌 요소의 값을 가져옴
    innerHTML : getElementById로 가져온 값을 변경할 때 사용

    ex)
    var count = document.getElementById('count');
    count.innerHTML = increase();
